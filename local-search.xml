<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GC笔记</title>
    <link href="/2021/07/15/GC/"/>
    <url>/2021/07/15/GC/</url>
    
    <content type="html"><![CDATA[<h2 id="一、GC是什么-分代收集算法"><a href="#一、GC是什么-分代收集算法" class="headerlink" title="一、GC是什么(分代收集算法)"></a>一、GC是什么(分代收集算法)</h2><p>频繁收集新生代</p><p>较少收集老年代</p><p>基本不动元空间</p><h2 id="二、判断对象是不是垃圾-对象存活判断"><a href="#二、判断对象是不是垃圾-对象存活判断" class="headerlink" title="二、判断对象是不是垃圾(对象存活判断)"></a>二、判断对象是不是垃圾(对象存活判断)</h2><h3 id="1、引用计数"><a href="#1、引用计数" class="headerlink" title="1、引用计数"></a>1、引用计数</h3><p><img src="/img/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.jpg" alt="引用计数"></p><p>循环引用</p><p><img src="/img/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.jpg" alt="循环引用"></p><h3 id="2、根可达-GcRoots可达性分析算法"><a href="#2、根可达-GcRoots可达性分析算法" class="headerlink" title="2、根可达 GcRoots可达性分析算法"></a>2、根可达 GcRoots可达性分析算法</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><img src="/img/%E8%B7%9F%E5%8F%AF%E8%BE%BE.jpg" alt="跟可达"></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><img src="/img/%E8%B7%9F%E5%8F%AF%E8%BE%BE%E5%88%86%E6%9E%90.jpg" alt="跟可达分析"></p><h4 id="Java中可以作为GCRoots的对象"><a href="#Java中可以作为GCRoots的对象" class="headerlink" title="Java中可以作为GCRoots的对象"></a>Java中可以作为GCRoots的对象</h4><p>1、虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象</p><p>2、方法区中的类静态属性引用的对象</p><p>3、方法区中常量引用的对象</p><p>4、本地方法栈中JNI（Native方法）引用的对象</p><p><img src="/img/case.jpg" alt="case"></p><h2 id="三、GC三大算法"><a href="#三、GC三大算法" class="headerlink" title="三、GC三大算法"></a>三、GC三大算法</h2><h3 id="1、GC算法总体概述"><a href="#1、GC算法总体概述" class="headerlink" title="1、GC算法总体概述"></a>1、GC算法总体概述</h3><blockquote><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。<br>因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC）</p><p>Minor GC和Full GC的区别<br>　　普通GC（minor GC）：只针对新生代区域的GC,指发生在新生代的垃圾收集动作，<br>因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快。 </p><p>　　全局GC（major GC or Full GC）：指发生在老年代的垃圾收集动作，出现了Major GC，<br>经常会伴随至少一次的Minor GC（但并不是绝对的）。Full GC的速度一般要比Minor GC慢上10倍以上 </p></blockquote><h4 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h4><p>年轻代中使用的是Minor GC，这种GC算法采用的是复制算法(Copying)</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><blockquote><p>Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old  generation中，也即一旦收集后，Eden是就变成空的了。<br>当对象在 Eden出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过-XX:MaxTenuringThreshold 来设定参数，java8起64位虚拟机不能超过15)，这些对象就会成为老年代。</p><p>-XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数<br>GC年龄采用4位bit存储，最大为15，例如MaxTenuringThreshold参数默认值就是15</p></blockquote><h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><p>年轻代中的GC,主要是复制算法（Copying）</p><p> HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p><p><img src="/img/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg" alt="复制算法"></p><h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><p>复制算法它的缺点也是相当明显的。<br>　　1、它浪费了to区的内存。<br>　　2、如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服to区的内存浪费。</p><h3 id="2、标记清除-Mark-Sweep"><a href="#2、标记清除-Mark-Sweep" class="headerlink" title="2、标记清除(Mark-Sweep)"></a>2、标记清除(Mark-Sweep)</h3><p>老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p><img src="/img/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.jpg" alt="标记清除"></p><p><img src="/img/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A42.jpg" alt="标记清除2"></p><h5 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h5><p>1、首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲<br>2、其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。 </p><h3 id="3-、标记压缩-Mark-Compact"><a href="#3-、标记压缩-Mark-Compact" class="headerlink" title="3 、标记压缩(Mark-Compact)"></a>3 、标记压缩(Mark-Compact)</h3><p>老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p><img src="/img/%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9.jpg" alt="标记压缩"></p><p>在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。<br>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 </p><h4 id="劣势-2"><a href="#劣势-2" class="headerlink" title="劣势"></a>劣势</h4><p>标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。<br>从效率上来说，标记/整理算法要低于复制算法。</p><h4 id="标记清除压缩-Mark-Sweep-Compact"><a href="#标记清除压缩-Mark-Sweep-Compact" class="headerlink" title="标记清除压缩(Mark-Sweep-Compact)"></a>标记清除压缩(Mark-Sweep-Compact)</h4><p><img src="/img/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%8E%8B%E7%BC%A9.jpg" alt="标记清除压缩"></p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>内存效率：复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。<br>内存整齐度：复制算法=标记整理算法&gt;标记清除算法。<br>内存利用率：标记整理算法=标记清除算法&gt;复制算法。 </p><p>可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JUC笔记</title>
    <link href="/2021/07/14/JUC%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/14/JUC%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Java多线程相关概念"><a href="#一、Java多线程相关概念" class="headerlink" title="一、Java多线程相关概念"></a>一、Java多线程相关概念</h2><h3 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h3><p>是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源</p><h3 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h3><p>在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务我们就可以看做是⼀个线程</p><p>⼀个进程会有1个或多个线程的</p><h3 id="3、线程有哪些状态？"><a href="#3、线程有哪些状态？" class="headerlink" title="3、线程有哪些状态？"></a>3、线程有哪些状态？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.State<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread which has not yet started.</span><br><span class="hljs-comment">     */</span><br>    NEW,(新建)<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="hljs-comment">     * state is executing in the Java virtual machine but it may</span><br><span class="hljs-comment">     * be waiting for other resources from the operating system</span><br><span class="hljs-comment">     * such as processor.</span><br><span class="hljs-comment">     */</span><br>    RUNNABLE,（准备就绪）<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="hljs-comment">     * A thread in the blocked state is waiting for a monitor lock</span><br><span class="hljs-comment">     * to enter a synchronized block/method or</span><br><span class="hljs-comment">     * reenter a synchronized block/method after calling</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125;.</span><br><span class="hljs-comment">     */</span><br>    BLOCKED,（阻塞）<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread.</span><br><span class="hljs-comment">     * A thread is in the waiting state due to calling one of the</span><br><span class="hljs-comment">     * following methods:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="hljs-comment">     * perform a particular action.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="hljs-comment">     * on an object is waiting for another thread to call</span><br><span class="hljs-comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="hljs-comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="hljs-comment">     * is waiting for a specified thread to terminate.</span><br><span class="hljs-comment">     */</span><br>    WAITING,（不见不散）<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread with a specified waiting time.</span><br><span class="hljs-comment">     * A thread is in the timed waiting state due to calling one of</span><br><span class="hljs-comment">     * the following methods with a specified positive waiting time:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     */</span><br>    TIMED_WAITING,（过时不候）<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a terminated thread.</span><br><span class="hljs-comment">     * The thread has completed execution.</span><br><span class="hljs-comment">     */</span><br>    TERMINATED;(终结)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、管程"><a href="#4、管程" class="headerlink" title="4、管程"></a>4、管程</h3><p>Monitor(监视器)，也就是我们平时所说的锁</p><p>Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</p><p>JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Object o = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (o)<br>    &#123;<br><br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br></code></pre></td></tr></table></figure><p>Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</p><h2 id="二、JUC是什么"><a href="#二、JUC是什么" class="headerlink" title="二、JUC是什么"></a>二、JUC是什么</h2><h3 id="1、java-util-concurrent在并发编程中使用的工具类"><a href="#1、java-util-concurrent在并发编程中使用的工具类" class="headerlink" title="1、java.util.concurrent在并发编程中使用的工具类"></a>1、java.util.concurrent在并发编程中使用的工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.concurrent    <br>java.util.concurrent.atomic    <br>java.util.concurrent.locks<br></code></pre></td></tr></table></figure><h3 id="2、wait-sleep的区别？"><a href="#2、wait-sleep的区别？" class="headerlink" title="2、wait/sleep的区别？"></a>2、wait/sleep的区别？</h3><p>wait放开手去睡，放开手里的锁<br>sleep握紧手去睡，醒了手里还有锁</p><h3 id="3、什么是并发？什么是并行？"><a href="#3、什么是并发？什么是并行？" class="headerlink" title="3、什么是并发？什么是并行？"></a>3、什么是并发？什么是并行？</h3><p>并发：同一时刻多个线程在访问同一个资源，多个线程对一个点<br>      例子：小米9今天上午10点，限量抢购<br>            春运抢票<br>            电商秒杀…<br>并行：多项工作一起执行，之后再汇总<br>      例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p><h3 id="4、进程-线程回顾"><a href="#4、进程-线程回顾" class="headerlink" title="4、进程/线程回顾"></a>4、进程/线程回顾</h3><h4 id="进程-线程是什么？"><a href="#进程-线程是什么？" class="headerlink" title="进程/线程是什么？"></a>进程/线程是什么？</h4><p>进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p><p>线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p><h4 id="进程-线程例子？"><a href="#进程-线程例子？" class="headerlink" title="进程/线程例子？"></a>进程/线程例子？</h4><p> 使用QQ，查看进程一定有一个QQ.exe的进程，我可以用qq和A文字聊天，和B视频聊天，给C传文件，给D发一段语言，QQ支持录入信息的搜索。</p><p>大四的时候写论文，用word写论文，同时用QQ音乐放音乐，同时用QQ聊天，多个进程。</p><p>word如没有保存，停电关机，再通电后打开word可以恢复之前未保存的文档，word也会检查你的拼写，两个线程：容灾备份，语法检查</p><h2 id="三、Lock接口"><a href="#三、Lock接口" class="headerlink" title="三、Lock接口"></a>三、Lock接口</h2><h3 id="1、复习Synchronized"><a href="#1、复习Synchronized" class="headerlink" title="1、复习Synchronized"></a>1、复习Synchronized</h3><h4 id="多线程编程模板上"><a href="#多线程编程模板上" class="headerlink" title="多线程编程模板上"></a>多线程编程模板上</h4><p>1、线程 操作 资源类</p><p>2、高内聚低耦合</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>1、创建资源类</p><p>2、资源类里创建同步方法、同步代码块</p><h4 id="例子卖票程序"><a href="#例子卖票程序" class="headerlink" title="例子卖票程序"></a>例子卖票程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">50</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span>) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;卖出第：&quot;</span> + (number--) + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot; 还剩下：&quot;</span> + number);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaleTicketDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       Ticket ticket = <span class="hljs-keyword">new</span> Ticket();<br>       <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">51</span>; i++) ticket.sale();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="2、Lock"><a href="#2、Lock" class="headerlink" title="2、Lock"></a>2、Lock</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects. </p><p>锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。</p><h4 id="Lock接口的实现"><a href="#Lock接口的实现" class="headerlink" title="Lock接口的实现"></a>Lock接口的实现</h4><p>ReentrantLock可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>     lock.lock();  <span class="hljs-comment">// block until condition holds</span><br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">// ... method body</span><br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       lock.unlock()<br>     &#125;<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="创建线程方式"><a href="#创建线程方式" class="headerlink" title="创建线程方式"></a>创建线程方式</h4><p>1、继承Thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaleTicket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span><br></code></pre></td></tr></table></figure><p>java是单继承，资源宝贵，要用接口方式 </p><p>2、Thread(Runnable target) </p><p>3、Thread(Runnable target, String name) </p><h4 id="实现runnable方法"><a href="#实现runnable方法" class="headerlink" title="实现runnable方法"></a>实现runnable方法</h4><p>1、新建类实现runnable接口</p><p>2、匿名内部类</p><p>3、lambda表达式</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span></span>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number=<span class="hljs-number">30</span>;<br> <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br> <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>&#123;<br>   lock.lock();<br>   <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span>(number &gt; <span class="hljs-number">0</span>) &#123;<br>     System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;卖出&quot;</span>+(number--)+<span class="hljs-string">&quot;\t 还剩number);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">   &#125; catch (Exception e) &#123;</span><br><span class="hljs-string">    e.printStackTrace();</span><br><span class="hljs-string">   &#125; finally &#123;</span><br><span class="hljs-string">    lock.unlock();</span><br><span class="hljs-string">   &#125;   </span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">                        </span><br><span class="hljs-string">public class SaleTicket </span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string"> public static void main(String[] args)</span><br><span class="hljs-string">   Ticket ticket = new Ticket();</span><br><span class="hljs-string"> new Thread(() -&gt; &#123;for (int i = 1; i &lt; 40; i++)ticket.sale();&#125;, &quot;</span>AA<span class="hljs-string">&quot;).start();</span><br><span class="hljs-string"> new Thread(() -&gt; &#123;for (int i = 1; i &lt; 40; i++)ticket.sale();&#125;, &quot;</span>BB<span class="hljs-string">&quot;).start();</span><br><span class="hljs-string"> new Thread(() -&gt; &#123;for (int i = 1; i &lt; 40; i++)ticket.sale();&#125;, &quot;</span>CC<span class="hljs-string">&quot;).start();</span><br><span class="hljs-string"> </span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">&#125;                        </span><br></code></pre></td></tr></table></figure><h2 id="四、多线程8锁案例"><a href="#四、多线程8锁案例" class="headerlink" title="四、多线程8锁案例"></a>四、多线程8锁案例</h2><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span>&#123;<br> <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSMS</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;------sendSMS&quot;</span>);<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendEmail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;------sendEmail&quot;</span>);<br> &#125; <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getHello</span><span class="hljs-params">()</span> </span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;------getHello&quot;</span>);<br> &#125; <br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 8锁</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> 1 标准访问，先打印短信还是邮件</span><br><span class="hljs-comment"> 2 停4秒在短信方法内，先打印短信还是邮件</span><br><span class="hljs-comment"> 3 新增普通的hello方法，是先打短信还是hello</span><br><span class="hljs-comment"> 4 现在有两部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> 5 两个静态同步方法，1部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> 6 两个静态同步方法，2部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> 7 1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> 8 1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> * ---------------------------------</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock_8</span></span><br><span class="hljs-class"></span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span><br><span class="hljs-function"> </span>&#123;<br> <br>   Phone phone = <span class="hljs-keyword">new</span> Phone();<br>   Phone phone2 = <span class="hljs-keyword">new</span> Phone();<br>   <br>   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>     phone.sendSMS();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>     e.printStackTrace();<br>    &#125;<br>   &#125;, <span class="hljs-string">&quot;AA&quot;</span>).start();<br>   <br>   Thread.sleep(<span class="hljs-number">100</span>);<br>   <br>   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>     phone.sendEmail();<br>     <span class="hljs-comment">//phone.getHello();</span><br>     <span class="hljs-comment">//phone2.sendEmail();</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>     e.printStackTrace();<br>    &#125;<br>   &#125;, <span class="hljs-string">&quot;BB&quot;</span>).start();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***  * 笔记</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  synchronized是实现同步的基础：Java中的每一个对象都可以作为锁。</span><br><span class="hljs-comment"> *  具体表现为以下3种形式。</span><br><span class="hljs-comment">    作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁；</span><br><span class="hljs-comment">    作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁；</span><br><span class="hljs-comment">    作用于代码块，对括号里配置的对象加锁。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *  1-2</span><br><span class="hljs-comment"> *  *  一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，</span><br><span class="hljs-comment"> *  *  其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法</span><br><span class="hljs-comment"> *  *  锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</span><br><span class="hljs-comment"> *  3-4</span><br><span class="hljs-comment"> *   *  加个普通方法后发现和同步锁无关</span><br><span class="hljs-comment"> *  *  换成两个对象后，不是同一把锁了，情况立刻变化。</span><br><span class="hljs-comment"> *  5-6</span><br><span class="hljs-comment"> *  都换成静态同步方法后，情况又变化</span><br><span class="hljs-comment"> *  若是普通同步方法，new     this,   具体的一部部手机,所有的普通同步方法用的都是同一把锁——实例对象本身，</span><br><span class="hljs-comment"> *  若是静态同步方法，static  Class ，唯一的一个模板</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  7-8</span><br><span class="hljs-comment"> *   *  当一个线程试图访问同步代码时它首先必须得到锁，退出或抛出异常时必须释放锁。</span><br><span class="hljs-comment"> *  *</span><br><span class="hljs-comment"> *  *  所有的普通同步方法用的都是同一把锁——实例对象本身，，就是new出来的具体实例对象本身</span><br><span class="hljs-comment"> *  *  也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁，</span><br><span class="hljs-comment"> *  *  可是别的实例对象的普通同步方法因为跟该实例对象的普通同步方法用的是不同的锁，所以不用等待该实例对象已获取锁的普通</span><br><span class="hljs-comment"> *  *  同步方法释放锁就可以获取他们自己的锁。</span><br><span class="hljs-comment"> *  *</span><br><span class="hljs-comment"> *  *  所有的静态同步方法用的也是同一把锁——类对象本身，就是我们说过的唯一模板Class</span><br><span class="hljs-comment"> *  *  具体实例对象this和唯一模板Class，这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的。</span><br><span class="hljs-comment"> *  *  但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁</span><br><span class="hljs-comment"> *  */</span><br></code></pre></td></tr></table></figure><p>结论</p><p>1、作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁；</p><p>2、作用于代码块，对括号里配置的对象加锁。</p><p>3、作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁；</p><p>注意：阿里手册第七条：能锁区块，就不要锁整个方法体，能用对象锁就不要类锁</p><h2 id="五、线程间通信"><a href="#五、线程间通信" class="headerlink" title="五、线程间通信"></a>五、线程间通信</h2><h3 id="1、案例：两个线程打印"><a href="#1、案例：两个线程打印" class="headerlink" title="1、案例：两个线程打印"></a>1、案例：两个线程打印</h3><h3 id="2、案例：四个线程打印"><a href="#2、案例：四个线程打印" class="headerlink" title="2、案例：四个线程打印"></a>2、案例：四个线程打印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">import</span> org.omg.IOP.Codec;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareData</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始值为零的一个变量</span><br><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>     <span class="hljs-comment">//判断</span><br>     <span class="hljs-keyword">while</span>(number!=<span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-keyword">this</span>.wait();<br>     &#125;<br>     <span class="hljs-comment">//干活</span><br>     ++number;<br>     System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; \t &quot;</span>+number);<br>     <span class="hljs-comment">//通知</span><br>     <span class="hljs-keyword">this</span>.notifyAll();;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>     <span class="hljs-comment">//判断</span><br>     <span class="hljs-keyword">while</span>(number!=<span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-keyword">this</span>.wait();<br>     &#125;<br>     <span class="hljs-comment">//干活</span><br>     --number;<br>     System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; \t &quot;</span>+number);<br>     <span class="hljs-comment">//通知</span><br>     <span class="hljs-keyword">this</span>.notifyAll();<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> *现在两个线程，</span><br><span class="hljs-comment"> * 可以操作初始值为零的一个变量，</span><br><span class="hljs-comment"> * 实现一个线程对该变量加1，一个线程对该变量减1，</span><br><span class="hljs-comment"> * 交替，来10轮。 </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * 笔记：Java里面如何进行工程级别的多线程编写</span><br><span class="hljs-comment"> * 1 多线程变成模板（套路）-----上</span><br><span class="hljs-comment"> *     1.1  线程    操作    资源类  </span><br><span class="hljs-comment"> *     1.2  高内聚  低耦合</span><br><span class="hljs-comment"> * 2 多线程变成模板（套路）-----下</span><br><span class="hljs-comment"> *     2.1  判断</span><br><span class="hljs-comment"> *     2.2  干活</span><br><span class="hljs-comment"> *     2.3  通知</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotifyWaitDemo</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     ShareData sd = <span class="hljs-keyword">new</span> ShareData();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            sd.increment();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();<br>     <br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            sd.decrement();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            sd.increment();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;C&quot;</span>).start();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            sd.decrement();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;D&quot;</span>).start();<br>     <br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * * </span><br><span class="hljs-comment"> * 2 多线程变成模板（套路）-----下</span><br><span class="hljs-comment"> *     2.1  判断</span><br><span class="hljs-comment"> *     2.2  干活</span><br><span class="hljs-comment"> *     2.3  通知</span><br><span class="hljs-comment"> * 3 防止虚假唤醒用while</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * */</span><br> <br></code></pre></td></tr></table></figure><p>注意：两个以上线程 判断条件if 要换成while 不然线程会出现错误，虚假唤醒</p><p>原因：在java多线程判断时，不能用if，程序出事出在了判断上面，<br>突然有一添加的线程进到if了，突然中断了交出控制权，<br>没有进行验证，而是直接走下去了，加了两次，甚至多次</p><p><img src="/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AFif%E9%97%AE%E9%A2%98.jpg" alt="多线程通讯if问题"></p><h3 id="3、java8新版实现"><a href="#3、java8新版实现" class="headerlink" title="3、java8新版实现"></a>3、java8新版实现</h3><p><img src="/img/lock%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%E5%9B%BE.jpg" alt="lock等待唤醒机制图"></p><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirCondition</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-comment">//1 判断</span><br>            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>)<br>            &#123;<br>                condition.await();<span class="hljs-comment">//this.wait();   //C A</span><br>            &#125;<br>            <span class="hljs-comment">//2 干活</span><br>            number++;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+number);<br>            <span class="hljs-comment">//3 通知</span><br>            condition.signalAll();<span class="hljs-comment">//this.notify();</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-comment">//1 判断</span><br>            <span class="hljs-keyword">while</span>(number == <span class="hljs-number">0</span>)<br>            &#123;<br>                condition.await();<span class="hljs-comment">//this.wait();</span><br>            &#125;<br>            <span class="hljs-comment">//2 干活</span><br>            number--;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+number);<br>            <span class="hljs-comment">//3 通知</span><br>            condition.signalAll();<span class="hljs-comment">//this.notify();</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-03-26 11:41</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 有一个初始值为零的变量，现有两个线程对该变量操作，</span><br><span class="hljs-comment"> * 实现一个线程对变量加1，实现一个线程对变量减1,交替来10次</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1 高内聚低耦合的前提下，线程       操作    资源类</span><br><span class="hljs-comment"> * 2 判断、干活、通知。</span><br><span class="hljs-comment"> * 3 防止虚假唤醒，用while</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProdConsumerDemo</span></span>&#123;<br>    <span class="hljs-keyword">static</span> Object objectLock = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        AirCondition airCondition = <span class="hljs-keyword">new</span> AirCondition();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//Thread.sleep(200);</span><br>                    airCondition.increment();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//Thread.sleep(300);</span><br>                    airCondition.decrement();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//Thread.sleep(400);</span><br>                    airCondition.increment();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;C&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//Thread.sleep(500);</span><br>                    airCondition.decrement();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;D&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、死锁"><a href="#4、死锁" class="headerlink" title="4、死锁"></a>4、死锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLock</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> Object A = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">static</span> Object B = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (A) &#123;<br>                System.out.println(<span class="hljs-string">&quot;持有锁A，希望锁B&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (B) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;获得B&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (B) &#123;<br>                System.out.println(<span class="hljs-string">&quot;持有锁B，希望锁A&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (A) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;获得A&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="调试并发问题的一些技巧"><a href="#调试并发问题的一些技巧" class="headerlink" title="调试并发问题的一些技巧"></a>调试并发问题的一些技巧</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">jps -l  查看进程<br>jstack [进程id]   打印错误<br>jconsole  java控制台<br></code></pre></td></tr></table></figure><h2 id="六、NotSafeDemo"><a href="#六、NotSafeDemo" class="headerlink" title="六、NotSafeDemo"></a>六、NotSafeDemo</h2><h3 id="1、集合类线程不安全"><a href="#1、集合类线程不安全" class="headerlink" title="1、集合类线程不安全"></a>1、集合类线程不安全</h3><blockquote><p>java.util.ConcurrentModificationException</p><p>ArrayList在迭代的时候如果同时对其进行修改就会<br>抛出java.util.ConcurrentModificationException异常<br>并发修改异常(system.out.print())</p></blockquote><h3 id="2、ArrayList"><a href="#2、ArrayList" class="headerlink" title="2、ArrayList"></a>2、ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//看ArrayList的源码</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、Vector"><a href="#3、Vector" class="headerlink" title="3、Vector"></a>3、Vector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br><span class="hljs-comment">//看Vector的源码</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    modCount++;<br>    ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);<br>    elementData[elementCount++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-comment">//有synchronized线程安全</span><br></code></pre></td></tr></table></figure><h3 id="4、Collections工具类"><a href="#4、Collections工具类" class="headerlink" title="4、Collections工具类"></a>4、Collections工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br><span class="hljs-comment">//Collections提供了方法synchronizedList保证list是同步线程安全的</span><br><br>Map&lt;Object, Object&gt; objectObjectMap = Collections.synchronizedMap(<span class="hljs-keyword">new</span> HashMap&lt;&gt;());<span class="hljs-comment">//map</span><br><br>Set&lt;Object&gt; objects = Collections.synchronizedSet(<span class="hljs-keyword">new</span> HashSet&lt;&gt;());<span class="hljs-comment">//set</span><br></code></pre></td></tr></table></figure><h3 id="5、CopyOnWrite"><a href="#5、CopyOnWrite" class="headerlink" title="5、CopyOnWrite"></a>5、CopyOnWrite</h3><h4 id="CopyOnWriteArrayList定义"><a href="#CopyOnWriteArrayList定义" class="headerlink" title="CopyOnWriteArrayList定义"></a>CopyOnWriteArrayList定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<span class="hljs-comment">//list</span><br>Map map = <span class="hljs-keyword">new</span> ConcurrentHashMap();<span class="hljs-comment">//map</span><br>Set set = <span class="hljs-keyword">new</span> CopyOnWriteArraySet();<span class="hljs-comment">//set</span><br></code></pre></td></tr></table></figure><p>A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.<br>CopyOnWriteArrayList是arraylist的一种线程安全变体，<br>其中所有可变操作（add、set等）都是通过生成底层数组的新副本来实现的。</p><h4 id="CopyOnWrite理论"><a href="#CopyOnWrite理论" class="headerlink" title="CopyOnWrite理论"></a>CopyOnWrite理论</h4><p>例如 ：名单签到</p><p><img src="/img/copyonwrite.jpg" alt="copyonwrite"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Appends the specified element to the end of this list.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> e element to be appended to this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; (as specified by &#123;<span class="hljs-doctag">@link</span> Collection#add&#125;)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-keyword">int</span> len = elements.length;<br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><blockquote><p>CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，<br>而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。<br>添加元素后，再将原容器的引用指向新的容器setArray(newElements)。<br>这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。<br>所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p></blockquote><h4 id="扩展类比"><a href="#扩展类比" class="headerlink" title="扩展类比"></a>扩展类比</h4><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<span class="hljs-comment">//线程不安全</span><br> <br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;&gt;();<span class="hljs-comment">//线程安全</span><br> <br><span class="hljs-comment">/*HashSet底层数据结构是什么？</span><br><span class="hljs-comment">HashMap  ?</span><br><span class="hljs-comment">但HashSet的add是放一个值，而HashMap是放K、V键值对</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;<br>    map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>&#125;<br> <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;<br>&#125;<br> <br> <br></code></pre></td></tr></table></figure><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//线程不安全</span><br> <br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<span class="hljs-comment">//线程安全</span><br> <br></code></pre></td></tr></table></figure><h2 id="七、线程间定制化调用通信"><a href="#七、线程间定制化调用通信" class="headerlink" title="七、线程间定制化调用通信"></a>七、线程间定制化调用通信</h2><p>需求：</p><p>多线程之间按顺序调用，实现A-&gt;B-&gt;C </p><p>三个线程启动，要求如下：</p><p>AA打印5次，BB打印10次，CC打印15次   ，接着</p><p>AA打印5次，BB打印10次，CC打印15次……来10轮 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareResource</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;<span class="hljs-comment">//1:A 2:B 3:C </span><br>  <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>  <span class="hljs-keyword">private</span> Condition c1 = lock.newCondition();<br>  <span class="hljs-keyword">private</span> Condition c2 = lock.newCondition();<br>  <span class="hljs-keyword">private</span> Condition c3 = lock.newCondition();<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print5</span><span class="hljs-params">(<span class="hljs-keyword">int</span> totalLoopNumber)</span></span>&#123;<br>     lock.lock();<br>     <span class="hljs-keyword">try</span>&#123;<br>       <span class="hljs-comment">//1 判断</span><br>       <span class="hljs-keyword">while</span>(number != <span class="hljs-number">1</span>)&#123;<br>          <span class="hljs-comment">//A 就要停止</span><br>          c1.await();<br>       &#125;<br>       <span class="hljs-comment">//2 干活</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span>; i++)&#123;<br>          System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+i+<span class="hljs-string">&quot;\t totalLoopNumber: &quot;</span>+totalLoopNumber);<br>       &#125;<br>       <span class="hljs-comment">//3 通知</span><br>       number = <span class="hljs-number">2</span>;<br>       c2.signal();<br>     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>       e.printStackTrace();<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       lock.unlock();<br>     &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print10</span><span class="hljs-params">(<span class="hljs-keyword">int</span> totalLoopNumber)</span></span>&#123;<br>     lock.lock();<br>     <span class="hljs-keyword">try</span>&#123;<br>       <span class="hljs-comment">//1 判断</span><br>       <span class="hljs-keyword">while</span>(number != <span class="hljs-number">2</span>)&#123;<br>          <span class="hljs-comment">//A 就要停止</span><br>          c2.await();<br>       &#125;<br>       <span class="hljs-comment">//2 干活</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++)&#123;<br>          System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+i+<span class="hljs-string">&quot;\t totalLoopNumber: &quot;</span>+totalLoopNumber);<br>       &#125;<br>       <span class="hljs-comment">//3 通知</span><br>       number = <span class="hljs-number">3</span>;<br>       c3.signal();<br>     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>       e.printStackTrace();<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       lock.unlock();<br>     &#125;<br>  &#125;  <br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print15</span><span class="hljs-params">(<span class="hljs-keyword">int</span> totalLoopNumber)</span></span>&#123;<br>     lock.lock();<br>     <span class="hljs-keyword">try</span>&#123;<br>       <span class="hljs-comment">//1 判断</span><br>       <span class="hljs-keyword">while</span>(number != <span class="hljs-number">3</span>)&#123;<br>          <span class="hljs-comment">//A 就要停止</span><br>          c3.await();<br>       &#125;<br>       <span class="hljs-comment">//2 干活</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">15</span>; i++)&#123;<br>          System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+i+<span class="hljs-string">&quot;\t totalLoopNumber: &quot;</span>+totalLoopNumber);<br>       &#125;<br>       <span class="hljs-comment">//3 通知</span><br>       number = <span class="hljs-number">1</span>;<br>       c1.signal();<br>     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>       e.printStackTrace();<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       lock.unlock();<br>     &#125;<br>  &#125;  <br>&#125;<br> <br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadOrderAccess</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     ShareResource sr = <span class="hljs-keyword">new</span> ShareResource();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++)&#123;<br>          sr.print5(i);<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;AA&quot;</span>).start();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++)&#123;<br>          sr.print10(i);<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;BB&quot;</span>).start();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++)&#123;<br>          sr.print15(i);<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;CC&quot;</span>).start();      <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八、Callable接口"><a href="#八、Callable接口" class="headerlink" title="八、Callable接口"></a>八、Callable接口</h2><h3 id="1、获得多线程的方法几种？"><a href="#1、获得多线程的方法几种？" class="headerlink" title="1、获得多线程的方法几种？"></a>1、获得多线程的方法几种？</h3><blockquote><p> 传统的是继承thread类和实现runnable接口，<br>java5以后又有实现callable接口和java的线程池获得</p></blockquote><h3 id="2、Callable接口是什么"><a href="#2、Callable接口是什么" class="headerlink" title="2、Callable接口是什么"></a>2、Callable接口是什么</h3><p>函数式接口 （支持lambda表达式）</p><p>java.util.concurrent</p><h3 id="3、与runnable对比"><a href="#3、与runnable对比" class="headerlink" title="3、与runnable对比"></a>3、与runnable对比</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//创建新类MyThread实现runnable接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br> <br> &#125;<br>&#125;<br><span class="hljs-comment">//新类MyThread2实现callable接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br> &#125; <br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="callable接口与runnable接口的区别？"><a href="#callable接口与runnable接口的区别？" class="headerlink" title="callable接口与runnable接口的区别？"></a>callable接口与runnable接口的区别？</h4><p>(1)是否有返回值<br>(2)是否抛异常<br>(3)落地方法不一样，一个是run，一个是call</p><h3 id="4、如何使用callable接口"><a href="#4、如何使用callable接口" class="headerlink" title="4、如何使用callable接口"></a>4、如何使用callable接口</h3><h4 id="直接替换runnable是否可行？"><a href="#直接替换runnable是否可行？" class="headerlink" title="直接替换runnable是否可行？"></a>直接替换runnable是否可行？</h4><p><img src="/img/callable1.jpg" alt="callable1"></p><h4 id="认识不同的人找中间人"><a href="#认识不同的人找中间人" class="headerlink" title="认识不同的人找中间人"></a>认识不同的人找中间人</h4><p><img src="/img/callable2.jpg" alt="callable2"></p><h3 id="5、FutureTask"><a href="#5、FutureTask" class="headerlink" title="5、FutureTask"></a>5、FutureTask</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p>未来的任务，用它就干一件事，异步调用<br>main方法就像一个冰糖葫芦，一个个方法由main串起来。<br>但解决不了一个问题：正常调用挂起堵塞问题</p><p> ￼<img src="/img/futuretask.jpg" alt="futuretask"><br>例子：<br>4个同学，A算1+20,B算21+30,C算31*到40,D算41+50，由于C的计算量有点大，<br>FutureTask单起个线程给C计算，先汇总ABD，最后等C计算完了再汇总C，拿到最终结果</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，<br>当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。</p><p>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p><p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，<br>就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。 </p><p>只计算一次<br><strong>get方法放到最后</strong></p></blockquote><p>​    ```</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;come in callable&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableDemo</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//FutureTask&lt;Integer&gt; futureTask = new FutureTask(new MyThread2());</span><br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;  come in callable&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;<br>        &#125;);<br>        FutureTask&lt;Integer&gt; futureTask2 = <span class="hljs-keyword">new</span> FutureTask(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;  come in callable&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2048</span>;<br>        &#125;);<br><br>        <span class="hljs-keyword">new</span> Thread(futureTask,<span class="hljs-string">&quot;zhang3&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(futureTask2,<span class="hljs-string">&quot;li4&quot;</span>).start();<br><br>        <span class="hljs-comment">//System.out.println(futureTask.get());</span><br>        <span class="hljs-comment">//System.out.println(futureTask2.get());</span><br>        <span class="hljs-comment">//1、一般放在程序后面，直接获取结果</span><br>        <span class="hljs-comment">//2、只会计算结果一次</span><br><br>        <span class="hljs-keyword">while</span>(!futureTask.isDone())&#123;<br>            System.out.println(<span class="hljs-string">&quot;***wait&quot;</span>);<br>        &#125;<br>        System.out.println(futureTask.get());<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; come over&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="九、ReentrantReadWriteLock读写锁"><a href="#九、ReentrantReadWriteLock读写锁" class="headerlink" title="九、ReentrantReadWriteLock读写锁"></a>九、ReentrantReadWriteLock读写锁</h2><p>案例：5个线程读，5个线程写入，操作同一个资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache</span> //资源类</span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">volatile</span> Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock readWriteLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String key,String value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        readWriteLock.writeLock().lock();<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 准备写入&quot;</span>);<br>            map.put(key,value);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 完成写入-----：&quot;</span>+value);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            readWriteLock.writeLock().unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        readWriteLock.readLock().lock();<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 准备读取&quot;</span>);<br>            String result = map.get(key);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 完成读取-----：&quot;</span>+result);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            readWriteLock.readLock().unlock();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 读写锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 对于同一个资源，我们涉及多线程的操作，有读，有写，交替进行。</span><br><span class="hljs-comment"> * 为了保证读写的数据一致性。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 读 读 可共享</span><br><span class="hljs-comment"> * 读 写 不共享</span><br><span class="hljs-comment"> * 写 写 不共享</span><br><span class="hljs-comment"> * 读的时候希望高并发同时进行，可以共享，可以多个线程同时操作进行中.....</span><br><span class="hljs-comment"> * 写的时候为了保证数据一致性，需要独占排它。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 题目：5个线程读，5个线程写入，操作同一个资源</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1 不加锁                不可以，写的时候原子性被破坏</span><br><span class="hljs-comment"> * 2 加ReentrantLock锁     写控制了，但是没有并发度，并发性能不好</span><br><span class="hljs-comment"> * 3 加读写锁               规范写入，写唯一，读并发</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockDemo</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        MyCache myCache = <span class="hljs-keyword">new</span> MyCache();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tmpI = i;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                myCache.write(tmpI+<span class="hljs-string">&quot;&quot;</span>,tmpI+<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tmpI = i;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                myCache.read(tmpI+<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="十、JUC强大的辅助类讲解"><a href="#十、JUC强大的辅助类讲解" class="headerlink" title="十、JUC强大的辅助类讲解"></a>十、JUC强大的辅助类讲解</h2><h3 id="1、CountDownLatch减少计数"><a href="#1、CountDownLatch减少计数" class="headerlink" title="1、CountDownLatch减少计数"></a>1、CountDownLatch减少计数</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</p><p>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</p><p>当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> *  *让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</span><br><span class="hljs-comment"> * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</span><br><span class="hljs-comment"> * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 解释：6个同学陆续离开教室后值班同学才可以关门。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatchDemo</span></span><br><span class="hljs-class"></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function">   </span>&#123;<br>         CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">6</span>);<br>       <br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">6</span>; i++) <span class="hljs-comment">//6个上自习的同学，各自离开教室的时间不一致</span><br>       &#123;<br>          <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>              System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 号同学离开教室&quot;</span>);<br>              countDownLatch.countDown();<br>          &#125;, String.valueOf(i)).start();<br>       &#125;<br>       countDownLatch.await();<br>       System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t****** 班长关门走人，main线程是班长&quot;</span>);<br>          <br>   &#125;<br> <br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、CyclicBarrier循环栅栏"><a href="#2、CyclicBarrier循环栅栏" class="headerlink" title="2、CyclicBarrier循环栅栏"></a>2、CyclicBarrier循环栅栏</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>CyclicBarrier的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。线程进入屏障通过CyclicBarrier的await()方法。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.BrokenBarrierException;<br><span class="hljs-keyword">import</span> java.util.concurrent.CyclicBarrier; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * CyclicBarrier</span><br><span class="hljs-comment"> * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</span><br><span class="hljs-comment"> * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</span><br><span class="hljs-comment"> * 直到最后一个线程到达屏障时，屏障才会开门，所有</span><br><span class="hljs-comment"> * 被屏障拦截的线程才会继续干活。</span><br><span class="hljs-comment"> * 线程进入屏障通过CyclicBarrier的await()方法。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 集齐7颗龙珠就可以召唤神龙</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierDemo</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUMBER = <span class="hljs-number">7</span>;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     <span class="hljs-comment">//CyclicBarrier(int parties, Runnable barrierAction) </span><br>     <br>     CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(NUMBER, ()-&gt;&#123;System.out.println(<span class="hljs-string">&quot;*****集齐7颗龙珠就可以召唤神龙&quot;</span>);&#125;) ;<br>     <br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">7</span>; i++) &#123;<br>       <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 星龙珠被收集 &quot;</span>);<br>            cyclicBarrier.await();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;, String.valueOf(i)).start();<br>     &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、Semaphore信号灯"><a href="#3、Semaphore信号灯" class="headerlink" title="3、Semaphore信号灯"></a>3、Semaphore信号灯</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>在信号量上我们定义两种操作：</p><p>acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1） 要么一直等下去，直到有线程释放信号量，或超时。</p><p>release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: TODO(这里用一句话描述这个类的作用)  </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 在信号量上我们定义两种操作：</span><br><span class="hljs-comment"> * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），</span><br><span class="hljs-comment"> *             要么一直等下去，直到有线程释放信号量，或超时。</span><br><span class="hljs-comment"> * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreDemo</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);<span class="hljs-comment">//模拟3个停车位</span><br>     <span class="hljs-comment">//模拟6部汽车</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">6</span>; i++)&#123;<br>       <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>          <span class="hljs-keyword">try</span>&#123;<br>            semaphore.acquire();<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 抢到了车位&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">5</span>));<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t------- 离开&quot;</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<span class="hljs-keyword">finally</span> &#123;<br>            semaphore.release();<br>          &#125;<br>       &#125;, String.valueOf(i)).start();<br>     &#125;  <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十一、BlockingQueueDemo阻塞队列"><a href="#十一、BlockingQueueDemo阻塞队列" class="headerlink" title="十一、BlockingQueueDemo阻塞队列"></a>十一、BlockingQueueDemo阻塞队列</h2><h3 id="1、栈与队列"><a href="#1、栈与队列" class="headerlink" title="1、栈与队列"></a>1、栈与队列</h3><p>栈：先进后出，后进先出</p><p>队列：先进先出</p><h3 id="2、阻塞队列"><a href="#2、阻塞队列" class="headerlink" title="2、阻塞队列"></a>2、阻塞队列</h3><p><img src="/img/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.jpg" alt="阻塞队列"></p><p>当队列是空的，从队列中获取元素的操作将会被阻塞<br>当队列是满的，从队列中添加元素的操作将会被阻塞</p><p>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</p><p>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</p><h3 id="3、阻塞队列的用处"><a href="#3、阻塞队列的用处" class="headerlink" title="3、阻塞队列的用处"></a>3、阻塞队列的用处</h3><p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</p><p>为什么需要BlockingQueue<br>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了</p><p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p><h3 id="4、架构梳理、种类分析"><a href="#4、架构梳理、种类分析" class="headerlink" title="4、架构梳理、种类分析"></a>4、架构梳理、种类分析</h3><h4 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h4><p><img src="/img/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9E%B6%E6%9E%84.jpg" alt="阻塞队列架构"></p><h4 id="种类分析"><a href="#种类分析" class="headerlink" title="种类分析"></a>种类分析</h4><p>1、ArrayBlockingQueue：由数组结构组成的有界阻塞队列。</p><p>2、LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</p><p>3、PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</p><p>4、DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</p><p>5、SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。</p><p>6、LinkedTransferQueue：由链表组成的无界阻塞队列。</p><p>7、LinkedBlockingDeque：由链表组成的双向阻塞队列。</p><h3 id="5、BlockingQueue核心方法"><a href="#5、BlockingQueue核心方法" class="headerlink" title="5、BlockingQueue核心方法"></a>5、BlockingQueue核心方法</h3><p><img src="/img/%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95.jpg" alt="队列方法"></p><p><strong>当阻塞队列满时</strong>，再往队列里add插入元素会抛IllegalStateException:Queuefull，<strong>当阻塞队列空时</strong>，再往队列里remove移除元素会抛NoSuchElementException</p><p>特殊值<strong>插入方法</strong>，成功ture失败false，<strong>移除方法</strong>，成功返回出队列的元素，队列里没有就返回null</p><p><strong>当阻塞队列满时</strong>，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据or响应中断退出   ，<strong>当阻塞队列空时</strong>，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用</p><p>超时退出，当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</p><h2 id="十二、ThreadPool线程池"><a href="#十二、ThreadPool线程池" class="headerlink" title="十二、ThreadPool线程池"></a>十二、ThreadPool线程池</h2><h3 id="1、为什么用线程池"><a href="#1、为什么用线程池" class="headerlink" title="1、为什么用线程池"></a>1、为什么用线程池</h3><p>例子：<br>10年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需要来回切换。<br>现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换效率高。</p><p>线程池的优势：<br>线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p><p>它的主要特点为：线程复用;控制最大并发数;管理线程。</p><p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><h3 id="2、线程池如何使用"><a href="#2、线程池如何使用" class="headerlink" title="2、线程池如何使用"></a>2、线程池如何使用</h3><h4 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h4><p><img src="/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%B6%E6%9E%84.jpg" alt="线程池架构"></p><p>Java中的线程池是通过Executor框架实现的，<br>该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类</p><h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*执行长期任务性能好，创建一个线程池，</span><br><span class="hljs-comment">一池有N个固定的线程，有固定线程数的线程*/</span><br>Executors.newFixedThreadPool(<span class="hljs-keyword">int</span>)<br><span class="hljs-comment">//一个任务一个任务的执行，一池一线程</span><br>Executors.newSingleThreadExecutor()<br><span class="hljs-comment">/*执行很多短期异步任务，线程池根据需要创建新线程，</span><br><span class="hljs-comment">但在先前构建的线程可用时将重用它们。可扩容，遇强则强*/</span><br>Executors.newCachedThreadPool()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadPoolDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//List list = new ArrayList();</span><br>        <span class="hljs-comment">//List list = Arrays.asList(&quot;a&quot;,&quot;b&quot;);</span><br>        <span class="hljs-comment">//固定数的线程池，一池五线程</span><br><br><span class="hljs-comment">//       ExecutorService threadPool =  Executors.newFixedThreadPool(5); //一个银行网点，5个受理业务的窗口</span><br><span class="hljs-comment">//       ExecutorService threadPool =  Executors.newSingleThreadExecutor(); //一个银行网点，1个受理业务的窗口</span><br>       ExecutorService threadPool =  Executors.newCachedThreadPool(); <span class="hljs-comment">//一个银行网点，可扩展受理业务的窗口</span><br><br>        <span class="hljs-comment">//10个顾客请求</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                threadPool.execute(()-&gt;&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 办理业务&quot;</span>);<br>                &#125;);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            threadPool.shutdown();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ThreadPoolExecutor底层原理"><a href="#ThreadPoolExecutor底层原理" class="headerlink" title="ThreadPoolExecutor底层原理"></a>ThreadPoolExecutor底层原理</h4><p><img src="/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.jpg" alt="线程池原理"></p><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h5><p>shutdown 方法调用后，ExecutorService 会有序关闭正在执行的任务，但是不接受新任务。<br>如果任务已经关闭，那么这个方法不会产生任何影响。</p><p>它会将线程池的状态设置为 SHUTWDOWN ，正在执行的任务会继续执行下去，线程池会等待任务的执行完毕，而没有执行的线程则会中断。</p><h5 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h5><p>shutdownNow 会尝试停止关闭所有正在执行的任务，停止正在等待的任务，并返回正在等待执行的任务列表。</p><p>shutdownNow 方法会将线程池的状态设置为 STOP，正在执行和等待的任务则被停止，返回等待执行的任务列表</p><h3 id="3、线程池几个重要参数"><a href="#3、线程池几个重要参数" class="headerlink" title="3、线程池几个重要参数"></a>3、线程池几个重要参数</h3><p>1、corePoolSize：线程池中的常驻核心线程数</p><p>2、maximumPoolSize：线程池中能够容纳同时执行的最大线程数，此值必须大于等于1</p><p>3、keepAliveTime：多余的空闲线程的存活时间当前池中线程数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止</p><p>4、unit：keepAliveTime的单位 </p><p>5、workQueue：任务队列，被提交但尚未被执行的任务</p><p>6、threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可</p><p>7、handler：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                          TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-params"><span class="hljs-function">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">                          RejectedExecutionHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-keyword">this</span>.handler = handler;<br>&#125;<br> <br></code></pre></td></tr></table></figure><h3 id="4、线程池底层工作原理"><a href="#4、线程池底层工作原理" class="headerlink" title="4、线程池底层工作原理"></a>4、线程池底层工作原理</h3><p><img src="/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" alt="线程池工作原理"></p><p>1、在创建了线程池后，开始等待请求。<br>2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：<br>  2.1如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；<br>  2.2如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；<br>  2.3如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；<br>  2.4如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。<br>3、当一个线程完成任务时，它会从队列中取下一个任务来执行。<br>4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：<br>    如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。<br>    所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</p><h3 id="5、线程池用哪个"><a href="#5、线程池用哪个" class="headerlink" title="5、线程池用哪个"></a>5、线程池用哪个</h3><h4 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h4><h5 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h5><p>等待队列已经排满了，再也塞不下新任务了同时，线程池中的max线程也达到了，无法继续为新任务服务。这个是时候我们就需要拒绝策略机制合理的处理这个问题。</p><h5 id="JDK内置的拒绝策略"><a href="#JDK内置的拒绝策略" class="headerlink" title="JDK内置的拒绝策略"></a>JDK内置的拒绝策略</h5><p>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</p><p>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</p><p>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前任务。</p><p>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。<br>如果允许任务丢失，这是最好的一种策略。</p><h5 id="以上内置拒绝策略均实现了RejectedExecutionHandle接口"><a href="#以上内置拒绝策略均实现了RejectedExecutionHandle接口" class="headerlink" title="以上内置拒绝策略均实现了RejectedExecutionHandle接口"></a>以上内置拒绝策略均实现了RejectedExecutionHandle接口</h5><h4 id="在工作中单一的-固定数的-可变的三种创建线程池的方法哪个用的多"><a href="#在工作中单一的-固定数的-可变的三种创建线程池的方法哪个用的多" class="headerlink" title="在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多"></a>在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多</h4><p>一个都不用，我们工作中只能使用自定义的</p><p>Executors中JDK已经给你提供了，为什么不用？</p><p><img src="/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%8B%E5%86%8C.jpg" alt="线程池手册"></p><h4 id="自定义线程池代码"><a href="#自定义线程池代码" class="headerlink" title="自定义线程池代码"></a>自定义线程池代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadPoolDemo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// List list = new ArrayList();</span><br>        ExecutorService threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<br>                <span class="hljs-number">2</span>,<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">2L</span>,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">3</span>),<br>                Executors.defaultThreadFactory(),<br>                <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());<br><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">8</span>; i++)&#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tmpI = i;<br>                threadPool.submit(() -&gt; &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 处理业务&quot;</span> + <span class="hljs-string">&quot;\t 顾客: &quot;</span> + tmpI);<br>                    <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>                &#125;);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            threadPool.shutdown();<br>        &#125;<br><br>    &#125;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initPool</span><span class="hljs-params">()</span></span>&#123;<br>        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<span class="hljs-comment">//一池5线程</span><br>        ExecutorService threadPool2 = Executors.newSingleThreadExecutor();<span class="hljs-comment">//一池1线程</span><br>        ExecutorService threadPool3 = Executors.newCachedThreadPool();<span class="hljs-comment">//一池N线程</span><br><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">20</span>; i++) &#123;<span class="hljs-comment">//模拟20个请求线程顾客，来办理业务，受理窗口目前有5个</span><br>                threadPool.submit(() -&gt; &#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 处理业务&quot;</span>);<br>                &#125;);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            threadPool.shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、生产中如设置合理线程池大小的设置"><a href="#6、生产中如设置合理线程池大小的设置" class="headerlink" title="6、生产中如设置合理线程池大小的设置"></a>6、生产中如设置合理线程池大小的设置</h3><h4 id="根据任务类型来配置线程池大小"><a href="#根据任务类型来配置线程池大小" class="headerlink" title="根据任务类型来配置线程池大小"></a>根据任务类型来配置线程池大小</h4><h5 id="如果是-CPU-密集型任务"><a href="#如果是-CPU-密集型任务" class="headerlink" title="如果是 CPU 密集型任务"></a>如果是 CPU 密集型任务</h5><p>如果是 CPU 密集型任务，那么就意味着 CPU 是稀缺资源，这个时候我们通常不能通过增加线程数来提高计算能力，因为线程数量太多，会导致频繁的上下文切换，一般这种情况下，</p><p>建议合理的线程数值是 N(CPU)数 + 1。</p><h5 id="如果是-I-O-密集型任务"><a href="#如果是-I-O-密集型任务" class="headerlink" title="如果是 I/O 密集型任务"></a>如果是 I/O 密集型任务</h5><p>如果是 I/O 密集型任务，就说明需要较多的等待，这个时候可以参考 Brain Goetz 的推荐方法 </p><p>线程数 = CPU核数 × (1 + 平均等待时间/平均工作时间)。</p><p>参考值可以是 N(CPU) 核数 * 2。</p><h4 id="当然，这只是一个参考值"><a href="#当然，这只是一个参考值" class="headerlink" title="当然，这只是一个参考值"></a>当然，这只是一个参考值</h4><p>具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM 体系结构</title>
    <link href="/2021/07/12/jvm/"/>
    <url>/2021/07/12/jvm/</url>
    
    <content type="html"><![CDATA[<h2 id="一、JVM体系结构概述"><a href="#一、JVM体系结构概述" class="headerlink" title="一、JVM体系结构概述"></a>一、JVM体系结构概述</h2><h3 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h3><p><img src="/img/jvm.jpg" alt="jvm"></p><h4 id="1、类装载器ClassLoader"><a href="#1、类装载器ClassLoader" class="headerlink" title="1、类装载器ClassLoader"></a>1、类装载器ClassLoader</h4><h5 id="类装载器"><a href="#类装载器" class="headerlink" title="类装载器"></a>类装载器</h5><p>负责加载class文件，class文件在文件开头有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定</p><p>类加载是一个将class字节码文件实例化成Class对象并进行相关初始化的过程。<br>全小写的class是关键字用来定义类，首字母大写的Class它是所有class的类。</p><p><img src="/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD.jpg" alt="类加载"></p><h5 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h5><p>1、启动类加载器（Bootstrap）C++</p><p>2、扩展类加载器（Extension）Java<br>第二层在JDK9版本中称为Platform ClassLoader即平台类加载器<br>JDK8及之前的加载器是Extension ClassLoader<br>System.getProperty(“java.ext.dirs”)</p><p>3、应用程序类加载器（AppClassLoader）Java也叫系统类加载器，加载当前应用的classpath的所有类</p><p>4、用户自定义加载器  Java.lang.ClassLoader的子类，用户可以定制类的加载方式</p><h5 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h5><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。 </p><p>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。 </p><blockquote><p>出问题往上怼，然后在一层一层去找</p></blockquote><p><img src="/img/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.jpg" alt="双亲委派"></p><p>好处：防止内存中出现多分同样的字节码（比如自定义一个java.lang.object类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Test.class.getClassLoader());<br>        System.out.println(Test.class.getClassLoader().getParent());<br>        System.out.println(Test.class.getClassLoader().getParent().getParent());<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="hljs-comment">sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br><span class="hljs-comment">null  Parent为Bootstrap，它是通过C++实现的并不存在于JVM体系内，所以输出为null</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Process finished with exit code 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        URL[] urLs = Launcher.getBootstrapClassPath().getURLs();<br>        <span class="hljs-keyword">for</span> (URL urL : urLs) &#123;<br>            System.out.println(urL.toExternalForm());<br><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">file:/C:/Program%20Files/Java/jdk1.8.0_202/jre/lib/resources.jar</span><br><span class="hljs-comment">file:/C:/Program%20Files/Java/jdk1.8.0_202/jre/lib/rt.jar</span><br><span class="hljs-comment">file:/C:/Program%20Files/Java/jdk1.8.0_202/jre/lib/sunrsasign.jar</span><br><span class="hljs-comment">file:/C:/Program%20Files/Java/jdk1.8.0_202/jre/lib/jsse.jar</span><br><span class="hljs-comment">file:/C:/Program%20Files/Java/jdk1.8.0_202/jre/lib/jce.jar</span><br><span class="hljs-comment">file:/C:/Program%20Files/Java/jdk1.8.0_202/jre/lib/charsets.jar</span><br><span class="hljs-comment">file:/C:/Program%20Files/Java/jdk1.8.0_202/jre/lib/jfr.jar</span><br><span class="hljs-comment">file:/C:/Program%20Files/Java/jdk1.8.0_202/jre/classes</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Process finished with exit code 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="2、Execution-Engine"><a href="#2、Execution-Engine" class="headerlink" title="2、Execution Engine"></a>2、Execution Engine</h4><p>Execution Engine执行引擎负责解释命令，提交操作系统执行。 </p><h4 id="3、Native-Interface本地接口"><a href="#3、Native-Interface本地接口" class="headerlink" title="3、Native Interface本地接口"></a>3、Native Interface本地接口</h4><p>本地接口的作用是融合不同的编程语言为 Java 所用</p><p>Java 诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraies</p><p>在企业级应用中已经比较少见。</p><h4 id="4、Native-Method-Stack"><a href="#4、Native-Method-Stack" class="headerlink" title="4、Native Method Stack"></a>4、Native Method Stack</h4><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p><h4 id="5、程序计数器（PC寄存器）"><a href="#5、程序计数器（PC寄存器）" class="headerlink" title="5、程序计数器（PC寄存器）"></a>5、程序计数器（PC寄存器）</h4><p>每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p><p>它是当前线程所执行的字节码的行号指示器</p><p>这块内存区域很小，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><h4 id="6、Method-Area-方法区"><a href="#6、Method-Area-方法区" class="headerlink" title="6、Method Area 方法区"></a>6、Method Area 方法区</h4><p>供各线程共享的运行时内存区域。<em><strong>它存储了每一个类的结构信息</strong></em><em><strong>（马甲）</strong></em>，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。</p><p><em><strong>But</strong></em>上面讲的是规范，在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)。</p><p><em><strong>实例变量存在堆内存中,和方法区无关</strong></em></p><h4 id="7、Stack栈"><a href="#7、Stack栈" class="headerlink" title="7、Stack栈"></a>7、Stack栈</h4><p>​    栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。</p><h5 id="栈存储什么"><a href="#栈存储什么" class="headerlink" title="栈存储什么?"></a>栈存储什么?</h5><p>栈帧中主要保存3 类数据：</p><p>本地变量（Local Variables）:输入参数和输出参数以及方法内的变量；</p><p>栈操作（Operand Stack）:记录出栈、入栈的操作；</p><p>栈帧数据（Frame Data）:包括类文件、方法等等。</p><h5 id="栈运行原理："><a href="#栈运行原理：" class="headerlink" title="栈运行原理："></a>栈运行原理：</h5><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，</p><p>遵循“先进后出”“后进先出”原则。</p><p>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K~756K之间,与等于1Mb左右。</p><p><img src="/img/%E6%A0%88.jpg" alt="栈"></p><p>每执行一个方法都会产生一个栈帧，保存到栈(后进先出)的顶部，顶部栈就是当前的方法，该方法执行完毕 后会自动将此栈帧出栈。</p><p>Exception in thread “main” java.lang.StackOverflowError</p><h4 id="8、栈-堆-方法区的交互关系"><a href="#8、栈-堆-方法区的交互关系" class="headerlink" title="8、栈+堆+方法区的交互关系"></a>8、栈+堆+方法区的交互关系</h4><p><img src="/img/%E6%A0%88%EF%BC%8C%E5%A0%86%EF%BC%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%85%B3%E7%B3%BB.jpg" alt="栈，堆，方法区关系"></p><p>HotSpot是使用指针的方式来访问对象：<br>Java堆中会存放访问类元数据的地址，<br>reference存储的就直接是对象的地址</p><h2 id="二、堆体系结构概述"><a href="#二、堆体系结构概述" class="headerlink" title="二、堆体系结构概述"></a>二、堆体系结构概述</h2><h3 id="1、heap堆-Java7之前"><a href="#1、heap堆-Java7之前" class="headerlink" title="1、heap堆(Java7之前)"></a>1、heap堆(Java7之前)</h3><p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行。</p><p>java7堆内存逻辑上分为三部分：新生+养老+永久</p><p>java8堆内存逻辑上分为三部分：新生+养老+元空间</p><p>java7图如下：</p><p><img src="img/%E5%A0%86java7.jpg" alt="堆java7"></p><h3 id="2、Heap-堆"><a href="#2、Heap-堆" class="headerlink" title="2、Heap 堆"></a>2、Heap 堆</h3><p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分：</p><p><img src="/img/%E5%A0%86.jpg" alt="堆"></p><h5 id="新生区（大致理解，后有详细）"><a href="#新生区（大致理解，后有详细）" class="headerlink" title="新生区（大致理解，后有详细）"></a>新生区（大致理解，后有详细）</h5><p>1、新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命</p><p>2、新生区又分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace） ，所有的类都是在伊甸区被new出来的。幸存区有两个： 0区（Survivor 0 space）和1区（Survivor 1 space）</p><p>3、当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。</p><p>4、若幸存 0区也满了，再对该区进行垃圾回收，然后移动到 1 区。</p><p>5、那如果1 区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生MajorGC（FullGC），进行养老区的内存清理</p><p>6、若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。</p><h5 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h5><p>如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二：<br>（1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。<br>（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。</p><h5 id="新生区（详细）"><a href="#新生区（详细）" class="headerlink" title="新生区（详细）"></a>新生区（详细）</h5><blockquote><p><strong>口诀：GC之后有交换，谁空谁是to</strong></p></blockquote><p><img src="/img/%E6%96%B0%E7%94%9F%E5%8C%BA.jpg" alt="新生区"></p><p>新生代：老年代 = 1：2</p><p>伊甸区：幸存0：幸存1= 8：1：1</p><p>1：eden、SurvivorFrom 复制到 SurvivorTo，年龄+1<br>首先，当Eden区满的时候会触发第一次GC,把还活着的对象拷贝到SurvivorFrom区，当Eden区再次触发GC的时候会扫描Eden区和From区域,对这两个区域进行垃圾回收，经过这次回收后还存活的对象,则直接复制到To区域（如果有对象的年龄已经达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1</p><p>2：清空 eden、SurvivorFrom<br>然后，清空Eden和SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to</p><p>3：SurvivorTo和 SurvivorFrom 互换<br>最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区。部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代</p><p>4：大对象特殊情况<br>如果分配的新对象比较大Eden区放不下但Old区可以放下时，对象会被直接分配到Old区（即没有晋升这一过程，直接到老年代了）</p><p>![Sun HotSpot内存管理](/img/Sun HotSpot内存管理.jpg)</p><h5 id="新生区为啥需要Survivor区"><a href="#新生区为啥需要Survivor区" class="headerlink" title="新生区为啥需要Survivor区"></a>新生区为啥需要Survivor区</h5><p>1、不就是新生代到老年代么，直接Eden到Old不好了吗？为啥要这么复杂？</p><blockquote><p>想想如果没有Survivor区，Eden区每进行一次MinorGC存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次MinorGC没有消灭但其实也并不会蹦跶多久，或许第2次第3次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。<em><strong>所以Survivor的存在意义就是减少被送到老年代的对象，进而减少FullGC的发生</strong></em>。Survivor的预筛选保证只有经历15次MinorGC还能在新生代中存活的对象，才会被送到老年代。</p></blockquote><p>2、新生区为啥需要两个Survivor区，为什么8:1:1？</p><blockquote><p><em><strong>设置两个Survivor区最大的好处就是解决内存碎片化。</strong></em></p><p>假设Survivor如果只有一个区域会怎样？MinorGC执行后Eden区被清空了，存活的对象放到了Survivor区，而之前Survivor区中的对象，可能也有一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为Survivor有2个区域，所以每次MinorGC，会将之前Eden区和From区中的存活对象复制到To区域。第二次MinorGC时，From与To职责兑换，这时候会将Eden区和To区中的存活对象再复制到From区域，以此反复。这种机制最大的好处就是，整个过程中，永远有一个Survivorspace是空的，另一个非空的Survivorspace是无碎片的。那么，Survivor为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果Survivor区再细分下去，每一块的空间就会比较小，容易导致Survivor区满，两块Survivor区是经过权衡之后的最佳方案。</p></blockquote><h3 id="3、方法区"><a href="#3、方法区" class="headerlink" title="3、方法区"></a>3、方法区</h3><p>实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。</p><p>对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代(Parmanent Gen)” ，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区(相当于是一个接口interface)的一个实现.</p><p><img src="/img/%E6%96%B9%E6%B3%95%E5%8C%BA.jpg" alt="方法区"></p><h4 id="永久区Perm-java7之前有"><a href="#永久区Perm-java7之前有" class="headerlink" title="永久区Perm(java7之前有)"></a>永久区Perm(java7之前有)</h4><p>​    永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。</p><h4 id="元空间Metaspace-java8"><a href="#元空间Metaspace-java8" class="headerlink" title="元空间Metaspace (java8)"></a>元空间Metaspace (java8)</h4><p>   区别于永久代，元空间在本地内存中分配。在jdk8里，Prem区中的所有内容中字符串常量移至堆内存，其他内容包括类元信息、字段、静态属性、方法、常量等都移动至元空间内</p><h2 id="三、堆参数调优入门"><a href="#三、堆参数调优入门" class="headerlink" title="三、堆参数调优入门"></a>三、堆参数调优入门</h2><h3 id="1、JVM垃圾收集-Java-Garbage-Collection-本次均以JDK1-8-HotSpot为例"><a href="#1、JVM垃圾收集-Java-Garbage-Collection-本次均以JDK1-8-HotSpot为例" class="headerlink" title="1、JVM垃圾收集(Java Garbage Collection )本次均以JDK1.8+HotSpot为例"></a>1、JVM垃圾收集(Java Garbage Collection )本次均以JDK1.8+HotSpot为例</h3><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p>java7</p><p><img src="/img/java7.jpg" alt="java7"></p><p>java 8</p><p>JDK 1.8之后将最初的永久代取消了，由元空间取代。</p><p><img src="/img/java8.jpg" alt="java8"></p><p>在Java8中，永久代已经被移除，被一个称为元空间的区域所取代。元空间的本质和永久代类似。</p><h4 id="原空间跟永久代的区别"><a href="#原空间跟永久代的区别" class="headerlink" title="原空间跟永久代的区别"></a>原空间跟永久代的区别</h4><p>永久带使用的JVM的堆内存，但是java8以后的元空间并不在虚拟机中而是使用本机物理内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p><p><img src="/img/%E5%85%83%E7%A9%BA%E9%97%B4%E6%B0%B8%E4%B9%85%E4%BB%A3.jpg" alt="元空间永久代"></p><h3 id="2、堆内存调优简介"><a href="#2、堆内存调优简介" class="headerlink" title="2、堆内存调优简介"></a>2、堆内存调优简介</h3><p><img src="/img/%E5%A0%86%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98.jpg" alt="堆内存调优"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();<span class="hljs-comment">//返回 Java 虚拟机试图使用的最大内存量。</span><br>        <span class="hljs-keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();<span class="hljs-comment">//返回 Java 虚拟机中的内存总量。</span><br>        System.out.println(<span class="hljs-string">&quot;TOTAL_MEMORY(-Xms) = &quot;</span> + totalMemory + <span class="hljs-string">&quot;（字节）、&quot;</span> + (totalMemory / (<span class="hljs-keyword">double</span>) <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;MAX_MEMORY(-Xmx) = &quot;</span> + maxMemory + <span class="hljs-string">&quot;（字节）、&quot;</span> + (maxMemory / (<span class="hljs-keyword">double</span>) <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">测试电脑运行内存8G</span><br><span class="hljs-comment">TOTAL_MEMORY(-Xms) = 128974848（字节）、123.0MB</span><br><span class="hljs-comment">MAX_MEMORY(-Xmx) = 1884815360（字节）、1797.5MB</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="VM参数"><a href="#VM参数" class="headerlink" title="VM参数"></a>VM参数</h4><p>-Xms1024m -Xmx1024m -XX:+PrintGCDetails (最大，最小内存1024m)</p><p><img src="/img/jvm%E5%8F%82%E6%95%B0.jpg" alt="jvm参数"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();<span class="hljs-comment">//返回 Java 虚拟机试图使用的最大内存量。</span><br>        <span class="hljs-keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();<span class="hljs-comment">//返回 Java 虚拟机中的内存总量。</span><br>        System.out.println(<span class="hljs-string">&quot;TOTAL_MEMORY(-Xms) = &quot;</span> + totalMemory + <span class="hljs-string">&quot;（字节）、&quot;</span> + (totalMemory / (<span class="hljs-keyword">double</span>) <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;MAX_MEMORY(-Xmx) = &quot;</span> + maxMemory + <span class="hljs-string">&quot;（字节）、&quot;</span> + (maxMemory / (<span class="hljs-keyword">double</span>) <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/jvm02.jpg" alt="jvm02"></p><p>-Xms8m -Xmx8m -XX:+PrintGCDetails</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String str = <span class="hljs-string">&quot;www.gjq.com&quot;</span> ;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)<br>        &#123;<br>            str += str + <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">88888888</span>) + <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">999999999</span>) ;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 1536K-&gt;488K(2048K)] 1536K-&gt;648K(7680K), <span class="hljs-number">0.0014273</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 1975K-&gt;497K(2048K)] 2135K-&gt;955K(7680K), <span class="hljs-number">0.0024335</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 1869K-&gt;360K(2048K)] 3198K-&gt;1906K(7680K), <span class="hljs-number">0.0007473</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 1261K-&gt;328K(2048K)] 6296K-&gt;5362K(7680K), <span class="hljs-number">0.0009032</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) --[PSYoungGen: 1229K-&gt;1229K(2048K)] 6264K-&gt;6264K(7680K), <span class="hljs-number">0.0006375</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Ergonomics)</span> [PSYoungGen: 1229K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(2048K)</span>] [ParOldGen: 5034K-&gt;2555<span class="hljs-title">K</span><span class="hljs-params">(5632K)</span>] 6264K-&gt;2555<span class="hljs-title">K</span><span class="hljs-params">(7680K)</span>, [Metaspace: 3230K-&gt;3230<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0032810 secs] [Times: user</span>=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 30K-&gt;0K(2048K)] 4329K-&gt;4299K(7680K), <span class="hljs-number">0.0003352</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] 4299K-&gt;4299K(7680K), <span class="hljs-number">0.0003112</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(2048K)</span>] [ParOldGen: 4299K-&gt;3239<span class="hljs-title">K</span><span class="hljs-params">(5632K)</span>] 4299K-&gt;3239<span class="hljs-title">K</span><span class="hljs-params">(7680K)</span>, [Metaspace: 3230K-&gt;3230<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0078687 secs] [Times: user</span>=<span class="hljs-number">0.03</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] 3239K-&gt;3239K(7680K), <span class="hljs-number">0.0005118</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(2048K)</span>] [ParOldGen: 3239K-&gt;3220<span class="hljs-title">K</span><span class="hljs-params">(5632K)</span>] 3239K-&gt;3220<span class="hljs-title">K</span><span class="hljs-params">(7680K)</span>, [Metaspace: 3230K-&gt;3230<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0070077 secs] [Times: user</span>=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>Heap<br> PSYoungGen      total 2048K, used 60K [<span class="hljs-number">0x00000000ffd80000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>  eden space 1536K, <span class="hljs-number">3</span>% used [<span class="hljs-number">0x00000000ffd80000</span>,<span class="hljs-number">0x00000000ffd8f360</span>,<span class="hljs-number">0x00000000fff00000</span>)<br>  from space 512K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x00000000fff80000</span>)<br>  to   space 512K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x0000000100000000</span>)<br> ParOldGen       total 5632K, used 3220K [<span class="hljs-number">0x00000000ff800000</span>, <span class="hljs-number">0x00000000ffd80000</span>, <span class="hljs-number">0x00000000ffd80000</span>)<br>  object space 5632K, <span class="hljs-number">57</span>% used [<span class="hljs-number">0x00000000ff800000</span>,<span class="hljs-number">0x00000000ffb250a8</span>,<span class="hljs-number">0x00000000ffd80000</span>)<br> Metaspace       used 3261K, capacity 4496K, committed 4864K, reserved 1056768K<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 353<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 388<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 512<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span><br><span class="hljs-class"><span class="hljs-title">Exception</span> <span class="hljs-title">in</span> <span class="hljs-title">thread</span> &quot;<span class="hljs-title">main</span>&quot; <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">OutOfMemoryError</span>: <span class="hljs-title">Java</span> <span class="hljs-title">heap</span> <span class="hljs-title">space</span></span><br><span class="hljs-class"><span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">Arrays</span>.<span class="hljs-title">copyOf</span>(<span class="hljs-title">Arrays</span>.<span class="hljs-title">java</span>:3332)</span><br><span class="hljs-class"><span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">AbstractStringBuilder</span>.<span class="hljs-title">ensureCapacityInternal</span>(<span class="hljs-title">AbstractStringBuilder</span>.<span class="hljs-title">java</span>:124)</span><br><span class="hljs-class"><span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">AbstractStringBuilder</span>.<span class="hljs-title">append</span>(<span class="hljs-title">AbstractStringBuilder</span>.<span class="hljs-title">java</span>:674)</span><br><span class="hljs-class"><span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">StringBuilder</span>.<span class="hljs-title">append</span>(<span class="hljs-title">StringBuilder</span>.<span class="hljs-title">java</span>:208)</span><br><span class="hljs-class"><span class="hljs-title">at</span> <span class="hljs-title">com</span>.<span class="hljs-title">aiguigu</span>.<span class="hljs-title">Test</span>.<span class="hljs-title">main</span>(<span class="hljs-title">Test</span>.<span class="hljs-title">java</span>:18)</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">Process</span> <span class="hljs-title">finished</span> <span class="hljs-title">with</span> <span class="hljs-title">exit</span> <span class="hljs-title">code</span> 1</span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p><img src="/img/jvm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" alt="jvm体系结构"></p><p><img src="/img/jvm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%842.jpg" alt="jvm体系结构2"></p><p>Java7永久区(字符串常量+元信息+字段+静态属性+方法+常量都永久代)</p><p>Java8元空间(字符串常量在堆，元信息+字段+静态属性+方法+常量在元空间)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2021/07/10/docker/"/>
    <url>/2021/07/10/docker/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Docker安装步骤"><a href="#一、Docker安装步骤" class="headerlink" title="一、Docker安装步骤"></a>一、Docker安装步骤</h2><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>docs.docker.com<span class="hljs-regexp">/engine/i</span>nstall<span class="hljs-regexp">/centos/</span><br></code></pre></td></tr></table></figure><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="1、中文手册"><a href="#1、中文手册" class="headerlink" title="1、中文手册"></a>1、中文手册</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>docs.docker-cn.com<span class="hljs-regexp">/engine/i</span>nstallation<span class="hljs-regexp">/linux/</span>docker-ce<span class="hljs-regexp">/centos/</span><span class="hljs-comment">#prerequisites</span><br></code></pre></td></tr></table></figure><h4 id="2、确定你是CentOS7及以上版本"><a href="#2、确定你是CentOS7及以上版本" class="headerlink" title="2、确定你是CentOS7及以上版本"></a>2、确定你是CentOS7及以上版本</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>redhat-release<br></code></pre></td></tr></table></figure><h4 id="3、yum安装gcc相关"><a href="#3、yum安装gcc相关" class="headerlink" title="3、yum安装gcc相关"></a>3、yum安装gcc相关</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> gcc<br>yum -y <span class="hljs-keyword">install</span> gcc-c++<br></code></pre></td></tr></table></figure><h4 id="4、卸载旧版本"><a href="#4、卸载旧版本" class="headerlink" title="4、卸载旧版本"></a>4、卸载旧版本</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$ sudo yum remove docker <span class="hljs-string">\</span><br>                  docker-client <span class="hljs-string">\</span><br>                  docker-client-latest <span class="hljs-string">\</span><br>                  docker-common <span class="hljs-string">\</span><br>                  docker-latest <span class="hljs-string">\</span><br>                  docker-latest-logrotate <span class="hljs-string">\</span><br>                  docker-logrotate <span class="hljs-string">\</span><br>                  docker-engine<br></code></pre></td></tr></table></figure><h4 id="5、安装需要的软件包"><a href="#5、安装需要的软件包" class="headerlink" title="5、安装需要的软件包"></a>5、安装需要的软件包</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">yum</span> install -y yum-utils device-mapper-persistent-<span class="hljs-class"><span class="hljs-keyword">data</span> lvm2</span><br></code></pre></td></tr></table></figure><h4 id="6、设置stable镜像仓库-推荐使用阿里云"><a href="#6、设置stable镜像仓库-推荐使用阿里云" class="headerlink" title="6、设置stable镜像仓库(推荐使用阿里云)"></a>6、设置stable镜像仓库(推荐使用阿里云)</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">yum-config-manager --add-repo http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo<br></code></pre></td></tr></table></figure><h4 id="7、更新yum软件包索引"><a href="#7、更新yum软件包索引" class="headerlink" title="7、更新yum软件包索引"></a>7、更新yum软件包索引</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yum makecache fast</span><br></code></pre></td></tr></table></figure><h4 id="8、安装DOCKER-CE"><a href="#8、安装DOCKER-CE" class="headerlink" title="8、安装DOCKER CE"></a>8、安装DOCKER CE</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">yum -<span class="hljs-keyword">y</span> install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io<br></code></pre></td></tr></table></figure><h4 id="9、启动docker"><a href="#9、启动docker" class="headerlink" title="9、启动docker"></a>9、启动docker</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker<br></code></pre></td></tr></table></figure><h4 id="10、测试"><a href="#10、测试" class="headerlink" title="10、测试"></a>10、测试</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">version</span><br>docker <span class="hljs-built_in">run</span> hello-world<br></code></pre></td></tr></table></figure><h4 id="11、卸载"><a href="#11、卸载" class="headerlink" title="11、卸载"></a>11、卸载</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">systemctl <span class="hljs-keyword">stop</span> docker <br>yum -<span class="hljs-keyword">y</span> <span class="hljs-built_in">remove</span> docker-<span class="hljs-keyword">ce</span><br>rm -rf /var/lib/docker<br></code></pre></td></tr></table></figure><h2 id="二、阿里云镜像加速"><a href="#二、阿里云镜像加速" class="headerlink" title="二、阿里云镜像加速"></a>二、阿里云镜像加速</h2><h3 id="阿里云官网"><a href="#阿里云官网" class="headerlink" title="阿里云官网"></a>阿里云官网</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/promotion.aliyun.com/ntms</span><span class="hljs-regexp">/act/kubernetes</span>.html<br>控制台-&gt;容器镜像服务-&gt;镜像工具-&gt;镜像加速器<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo tee <span class="hljs-regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br><span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://9m356yy6.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="三、Docker常用命令"><a href="#三、Docker常用命令" class="headerlink" title="三、Docker常用命令"></a>三、Docker常用命令</h2><h3 id="1、帮助启动类命令"><a href="#1、帮助启动类命令" class="headerlink" title="1、帮助启动类命令"></a>1、帮助启动类命令</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">启动docker： systemctl <span class="hljs-keyword">start</span> docker<br>停止docker： systemctl stop docker<br>重启docker： systemctl <span class="hljs-keyword">restart</span> docker<br>查看docker状态： systemctl status docker<br>开机启动： systemctl <span class="hljs-keyword">enable</span> docker<br>查看docker概要信息： docker <span class="hljs-keyword">info</span><br>查看docker帮助文档： docker <span class="hljs-comment">--help</span><br></code></pre></td></tr></table></figure><h3 id="2、镜像命令"><a href="#2、镜像命令" class="headerlink" title="2、镜像命令"></a>2、镜像命令</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker images  列出本地主机上的镜像<br>docker search 某个XXX镜像名字<br>docker pull 某个XXX镜像名字<br>docker rmi 某个XXX镜像名字ID<br>docker rmi  -f 镜像ID<br>docker rmi -f 镜像名<span class="hljs-number">1</span>:<span class="hljs-keyword">TAG</span> <span class="hljs-title">镜像名2</span>:<span class="hljs-keyword">TAG</span> <br><span class="hljs-title">docker</span> rmi -f $(docker images -qa)    <br></code></pre></td></tr></table></figure><h3 id="3、容器命令"><a href="#3、容器命令" class="headerlink" title="3、容器命令"></a>3、容器命令</h3><h4 id="新建-启动容器"><a href="#新建-启动容器" class="headerlink" title="新建+启动容器"></a>新建+启动容器</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs awk"> docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br> OPTIONS说明（常用）：有些是一个减号，有些是两个减号<br> <br>--name=<span class="hljs-string">&quot;容器新名字&quot;</span>: 为容器指定一个名称；<br>-d: 后台运行容器，并返回容器ID，也即启动守护式容器；<br> <br>-i：以交互模式运行容器，通常与 -t 同时使用；<br>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br> <br>-P: 随机端口映射；大写P<br>-p: 指定端口映射，有以下四种格式 小写p<br>      ip:hostPort:containerPort<br>      ip::containerPort<br>      hostPort:containerPort<br>      containerPort<br>      <br>例:      <br><span class="hljs-comment">#使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span><br>docker run -it centos <span class="hljs-regexp">/bin/</span>bash <br> <br>参数说明：<br>-i: 交互式操作。<br>-t: 终端。<br>centos : centos 镜像。<br><span class="hljs-regexp">/bin/</span>bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 <span class="hljs-regexp">/bin/</span>bash。<br>要退出终端，直接输入 <span class="hljs-keyword">exit</span>:<br></code></pre></td></tr></table></figure><h4 id="列出当前所有正在运行的容器"><a href="#列出当前所有正在运行的容器" class="headerlink" title="列出当前所有正在运行的容器"></a>列出当前所有正在运行的容器</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff">docker ps [OPTIONS]<br>OPTIONS说明（常用）：<br><span class="hljs-deletion">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class="hljs-deletion">-l :显示最近创建的容器。</span><br><span class="hljs-deletion">-n：显示最近n个创建的容器。</span><br><span class="hljs-deletion">-q :静默模式，只显示容器编号。</span><br></code></pre></td></tr></table></figure><h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span>  容器停止退出<br>ctrl+P+Q  容器不停止退出<br></code></pre></td></tr></table></figure><h4 id="启动已停止运行的容器"><a href="#启动已停止运行的容器" class="headerlink" title="启动已停止运行的容器"></a>启动已停止运行的容器</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker <span class="hljs-literal">start</span> 容器ID或者容器名<br></code></pre></td></tr></table></figure><h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">docker <span class="hljs-built_in">restart</span> 容器ID或者容器名<br></code></pre></td></tr></table></figure><h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker stop 容器ID或者容器名<br></code></pre></td></tr></table></figure><h4 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> 容器ID或者容器名<br></code></pre></td></tr></table></figure><h4 id="删除已停止的容器"><a href="#删除已停止的容器" class="headerlink" title="删除已停止的容器"></a>删除已停止的容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> 容器ID<br>一次性删除多个容器<br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span>(docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span>)<br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span> | xargs docker <span class="hljs-built_in">rm</span><br></code></pre></td></tr></table></figure><h4 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h4><h5 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的运行模式。<br>docker <span class="hljs-builtin-name">run</span> -d 容器名<br>例：<br>redis case  前台   docker <span class="hljs-builtin-name">run</span> -it redis:6.0.8<br>            后台   docker <span class="hljs-builtin-name">run</span> -d redis:6.0.8   /  docker exec -it 容器ID /bin/bash<br></code></pre></td></tr></table></figure><h5 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h5><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haml">docker logs -f -t --tail 容器ID<br>   -<span class="ruby">t 是加入时间戳</span><br><span class="ruby"></span>   -<span class="ruby">f 跟随最新的日志打印</span><br><span class="ruby"></span>   -<span class="ruby">-tail 数字 显示最后多少条</span><br><span class="ruby"></span>查看容器内运行的进程  docker top 容器ID<br>查看容器内部细节  docker inspect 容器ID<br></code></pre></td></tr></table></figure><h5 id="进入正在运行的容器并以命令行交互"><a href="#进入正在运行的容器并以命令行交互" class="headerlink" title="进入正在运行的容器并以命令行交互"></a>进入正在运行的容器并以命令行交互</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker exec -it 容器ID bashShell<br>重新进入  docker attach 容器ID<br><br>attach和exec 区别<br>attach 直接进入容器启动命令的终端，不会启动新的进程<br>用<span class="hljs-keyword">exit</span>退出，会导致容器的停止。<br><br>exec 是在容器中打开新的终端，并且可以启动新的进程<br>用<span class="hljs-keyword">exit</span>退出，不会导致容器的停止。<br><br>推荐使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。<br></code></pre></td></tr></table></figure><h5 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">docker</span> <span class="hljs-meta">cp</span>  容器ID:容器内路径 目的主机路径 <br></code></pre></td></tr></table></figure><h2 id="四、Docker-镜像"><a href="#四、Docker-镜像" class="headerlink" title="四、Docker 镜像"></a>四、Docker 镜像</h2><h3 id="Docker镜像commit操作"><a href="#Docker镜像commit操作" class="headerlink" title="Docker镜像commit操作"></a>Docker镜像commit操作</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker commit <span class="hljs-attribute">-m</span>=“提交的描述信息” <span class="hljs-attribute">-a</span>=“作者” 容器ID 要创建的目标镜像名:[标签名]<br></code></pre></td></tr></table></figure><h2 id="五、本地镜像发布阿里云"><a href="#五、本地镜像发布阿里云" class="headerlink" title="五、本地镜像发布阿里云"></a>五、本地镜像发布阿里云</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">控制台-&gt;容器镜像服务-&gt;实例子列表-&gt;创建实例-&gt;创建命名空间-&gt;创建仓库<br></code></pre></td></tr></table></figure><h3 id="1-登录阿里云Docker-Registry"><a href="#1-登录阿里云Docker-Registry" class="headerlink" title="1. 登录阿里云Docker Registry"></a>1. 登录阿里云Docker Registry</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ docker <span class="hljs-keyword">login</span> <span class="hljs-comment">--username=almighty咔咔 registry.cn-hangzhou.aliyuncs.com</span><br></code></pre></td></tr></table></figure><p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</p><p>您可以在访问凭证页面修改凭证密码。</p><h3 id="2-从Registry中拉取镜像"><a href="#2-从Registry中拉取镜像" class="headerlink" title="2. 从Registry中拉取镜像"></a>2. 从Registry中拉取镜像</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ docker pull registry<span class="hljs-selector-class">.cn-hangzhou</span><span class="hljs-selector-class">.aliyuncs</span>.com/docker_play/mytomcat:<span class="hljs-selector-attr">[镜像版本号]</span><br></code></pre></td></tr></table></figure><h3 id="3-将镜像推送到Registry"><a href="#3-将镜像推送到Registry" class="headerlink" title="3. 将镜像推送到Registry"></a>3. 将镜像推送到Registry</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ docker login --username=almighty咔咔 registry<span class="hljs-selector-class">.cn-hangzhou</span><span class="hljs-selector-class">.aliyuncs</span>.com$ docker tag <span class="hljs-selector-attr">[ImageId]</span> registry<span class="hljs-selector-class">.cn-hangzhou</span><span class="hljs-selector-class">.aliyuncs</span>.com/docker_play/mytomcat:<span class="hljs-selector-attr">[镜像版本号]</span>$ docker push registry<span class="hljs-selector-class">.cn-hangzhou</span><span class="hljs-selector-class">.aliyuncs</span>.com/docker_play/mytomcat:<span class="hljs-selector-attr">[镜像版本号]</span><br></code></pre></td></tr></table></figure><p>请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p><h3 id="4-选择合适的镜像仓库地址"><a href="#4-选择合适的镜像仓库地址" class="headerlink" title="4. 选择合适的镜像仓库地址"></a>4. 选择合适的镜像仓库地址</h3><p>从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。</p><p>如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录。</p><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h3><p>使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ docker images<br>REPOSITORY                            <span class="hljs-keyword">TAG</span>            <span class="hljs-title">IMAGE</span> ID            CREATED             VIRTUAL SIZE registry.aliyuncs.com/acs/agent       <span class="hljs-number">0.7</span>-dfb6816    <span class="hljs-number">37</span>bb9c63c8b2        <span class="hljs-number">7</span> days ago          <span class="hljs-number">37.89</span> MB<br>$ docker <span class="hljs-keyword">tag</span> <span class="hljs-title">37bb9c63c8b2</span> registry-vpc.cn-hangzhou.aliyuncs.com/acs/agent:<span class="hljs-number">0.7</span>-dfb6816<br></code></pre></td></tr></table></figure><p>使用 “docker push” 命令将该镜像推送至远程。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ docker <span class="hljs-keyword">push</span> registry-vpc.cn-hangzhou.aliyuncs.com<span class="hljs-regexp">/acs/</span>agent:<span class="hljs-number">0.7</span>-dfb6816<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>redis五个类型的应用场景</title>
    <link href="/2021/07/05/redis%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8/"/>
    <url>/2021/07/05/redis%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="两个小细节"><a href="#两个小细节" class="headerlink" title="两个小细节"></a>两个小细节</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1</span>、命令不区分大小写 key区分<br><span class="hljs-number">2</span>、<span class="hljs-symbol">help@</span><br></code></pre></td></tr></table></figure><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><h3 id="1、商品编号、订单采用incr命令生成"><a href="#1、商品编号、订单采用incr命令生成" class="headerlink" title="1、商品编号、订单采用incr命令生成"></a>1、商品编号、订单采用incr命令生成</h3><h3 id="2、文章点赞点踩"><a href="#2、文章点赞点踩" class="headerlink" title="2、文章点赞点踩"></a>2、文章点赞点踩</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">点击喜欢作者<br>incr <span class="hljs-keyword">items</span>:<span class="hljs-number">001</span> 点赞<br><span class="hljs-built_in">get</span>  <span class="hljs-keyword">items</span>:<span class="hljs-number">001</span> 喜欢作者人数<br></code></pre></td></tr></table></figure><h2 id="hash："><a href="#hash：" class="headerlink" title="hash："></a>hash：</h2><h3 id="购物车-快递-订餐"><a href="#购物车-快递-订餐" class="headerlink" title="购物车,快递,订餐"></a>购物车,快递,订餐</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">购物车</span>  <span class="hljs-attr">shopcar :</span> <span class="hljs-string">uid</span><br><span class="hljs-string">用户id</span>  <span class="hljs-number">1024</span><br><span class="hljs-string">产品id</span>  <span class="hljs-number">334488</span> <br><span class="hljs-string">数量</span> <span class="hljs-number">1</span><br><br><span class="hljs-number">1</span><span class="hljs-string">、新增商品:</span> <span class="hljs-attr">hset shopcar :</span> <span class="hljs-string">uid</span>  <span class="hljs-number">1024  </span><span class="hljs-number">334488</span> <span class="hljs-number">1</span><br><span class="hljs-number">2</span><span class="hljs-string">、新增商品:</span> <span class="hljs-attr">hset shopcar :</span> <span class="hljs-string">uid</span>  <span class="hljs-number">1024  </span><span class="hljs-number">334477</span> <span class="hljs-number">1</span><br><span class="hljs-number">3</span><span class="hljs-string">、增加商品数量:</span> <span class="hljs-attr">hincrby shopcar :</span> <span class="hljs-string">uid</span>  <span class="hljs-number">1024  </span><span class="hljs-number">334477</span> <span class="hljs-number">1</span>  <span class="hljs-string">(2增加一个)</span><br><span class="hljs-number">4</span><span class="hljs-string">、商品总数:</span> <span class="hljs-attr">hlen shopcar:</span> <span class="hljs-string">uid</span> <span class="hljs-number">1024</span><br><span class="hljs-number">5</span><span class="hljs-string">、全部选择:</span> <span class="hljs-string">hgetall</span> <span class="hljs-string">shopcar:uid</span> <span class="hljs-number">1024</span><br></code></pre></td></tr></table></figure><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="订阅微信公众号"><a href="#订阅微信公众号" class="headerlink" title="订阅微信公众号"></a>订阅微信公众号</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tcl">例：我关注了李永乐老师和csdn的微信号<br><span class="hljs-number">1</span>、李永乐老师和csdn发布文章分别是<span class="hljs-number">11</span> 和 <span class="hljs-number">22</span><br><span class="hljs-number">2</span>、如果我关注他们，只要他们发布新文章，就会安装进我的<span class="hljs-keyword">list</span><br><span class="hljs-number">3</span>、查看订阅的全部文章分页显示<br><br><br>我订阅的作者     likeauthor:uid1024<br>文章 <span class="hljs-number">11</span>  <br>文章 <span class="hljs-number">22</span><br><br>lpush likeauthor:uid1024   <span class="hljs-number">11</span> <span class="hljs-number">22</span><br><span class="hljs-keyword">lrange</span> likeauthor:uid1024   <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="1、微信抽奖小程序"><a href="#1、微信抽奖小程序" class="headerlink" title="1、微信抽奖小程序"></a>1、微信抽奖小程序</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing">参与抽奖   sadd <span class="hljs-built_in">key</span> 用户id<br>显示多少人参与  scard <span class="hljs-built_in">key</span><br>抽奖（从<span class="hljs-built_in">set</span>中任意选取N个中奖人）<br>srandmember <span class="hljs-built_in">key</span> <span class="hljs-number">2</span>  随机抽两个人 ，元素不删除             spop <span class="hljs-built_in">key</span> <span class="hljs-number">3</span>         随机抽三个人，元素会删除<br></code></pre></td></tr></table></figure><h3 id="2、微信朋友圈点赞"><a href="#2、微信朋友圈点赞" class="headerlink" title="2、微信朋友圈点赞"></a>2、微信朋友圈点赞</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">新增点赞    sadd <span class="hljs-keyword">pu</span><span class="hljs-variable">b:msgID</span>   点赞用户id1  点赞用户id2<br>取消点赞    srem <span class="hljs-keyword">pu</span><span class="hljs-variable">b:msgID</span>   点赞用户id<br>显示所有点赞用户   smember <span class="hljs-keyword">pu</span><span class="hljs-variable">b:msgID</span>  <br>点赞用户数统计     scard <span class="hljs-keyword">pu</span><span class="hljs-variable">b:msgID</span> <br>判断某个朋友是否对楼主点赞过 sismember <span class="hljs-keyword">pu</span><span class="hljs-variable">b:msgID</span>  用户id<br></code></pre></td></tr></table></figure><h3 id="3、微博好友关注社交关系"><a href="#3、微博好友关注社交关系" class="headerlink" title="3、微博好友关注社交关系"></a>3、微博好友关注社交关系</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>）共同关注的人  <br><span class="hljs-keyword">sadd</span>  <span class="hljs-built_in">s1</span>  <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-keyword">sadd</span>  <span class="hljs-built_in">s2</span>  <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">sinter</span>  <span class="hljs-built_in">s1</span> <span class="hljs-built_in">s2</span> <br><br><br><span class="hljs-number">2</span>）我关注的人也关注了他（大家爱好相同）<br><br><span class="hljs-symbol">s1</span>是我  <span class="hljs-built_in">s2</span>代表余承东  <span class="hljs-built_in">s3</span> 代表张召忠<br><span class="hljs-keyword">sadd</span>  <span class="hljs-built_in">s1</span>  <span class="hljs-built_in">s2</span>  <span class="hljs-number">3</span>        我关注余承东和张召忠<br><span class="hljs-symbol">sismember</span> <span class="hljs-built_in">s1</span> <span class="hljs-number">3</span>         判断我是否关注张召忠<br><span class="hljs-symbol">sismember</span> <span class="hljs-built_in">s2</span> <span class="hljs-number">3</span>         判断余承东是否关注张召忠<br>两个都是true <br></code></pre></td></tr></table></figure><h3 id="4、qq内推可能认识的人"><a href="#4、qq内推可能认识的人" class="headerlink" title="4、qq内推可能认识的人"></a>4、qq内推可能认识的人</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sadd</span>  s<span class="hljs-number">1</span>  <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>  <br><span class="hljs-attribute">sadd</span>  s<span class="hljs-number">2</span>  <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br><span class="hljs-attribute">sinter</span> s<span class="hljs-number">1</span> s<span class="hljs-number">2</span>  (我们俩共有的好友) <br><span class="hljs-attribute">sdiff</span> s<span class="hljs-number">1</span> s<span class="hljs-number">2</span>   (推荐s<span class="hljs-number">2</span> 可能认识的人(来自s<span class="hljs-number">1</span>好友))<br><span class="hljs-attribute">sdiff</span> s<span class="hljs-number">2</span> s<span class="hljs-number">1</span>   (推荐s<span class="hljs-number">1</span> 可能认识的人(来自s<span class="hljs-number">2</span>好友))<br></code></pre></td></tr></table></figure><h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><h3 id="抖音热搜"><a href="#抖音热搜" class="headerlink" title="抖音热搜"></a>抖音热搜</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>、点击视频 zincrby hotvcr:<span class="hljs-number">20200919</span>  <span class="hljs-number">1</span> 八佰 <br>       <span class="hljs-attribute">zincrby</span> hotvcr:<span class="hljs-number">20200919</span>  <span class="hljs-number">15</span> 八佰  <span class="hljs-number">2</span>花木兰<br><span class="hljs-attribute">2</span>、展示当日排行前<span class="hljs-number">10</span>条<br>      <span class="hljs-attribute">zrevrange</span> hotvcr:<span class="hljs-number">20200919</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> withscores<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
