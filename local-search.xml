<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GC笔记</title>
    <link href="/2021/07/15/GC/"/>
    <url>/2021/07/15/GC/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="一、GC是什么-分代收集算法"><a href="#一、GC是什么-分代收集算法" class="headerlink" title="一、GC是什么(分代收集算法)"></a>一、GC是什么(分代收集算法)</h2><p>频繁收集新生代</p><p>较少收集老年代</p><p>基本不动元空间</p><h2 id="二、判断对象是不是垃圾-对象存活判断"><a href="#二、判断对象是不是垃圾-对象存活判断" class="headerlink" title="二、判断对象是不是垃圾(对象存活判断)"></a>二、判断对象是不是垃圾(对象存活判断)</h2><h3 id="1、引用计数"><a href="#1、引用计数" class="headerlink" title="1、引用计数"></a>1、引用计数</h3><p><img src="%5Cimg%5C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.jpg" alt="引用计数"></p><p>循环引用</p><p><img src="%5Cimg%5C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.jpg" alt="循环引用"></p><h3 id="2、根可达-GcRoots可达性分析算法"><a href="#2、根可达-GcRoots可达性分析算法" class="headerlink" title="2、根可达 GcRoots可达性分析算法"></a>2、根可达 GcRoots可达性分析算法</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><img src="%5Cimg%5C%E8%B7%9F%E5%8F%AF%E8%BE%BE.jpg" alt="跟可达"></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><img src="%5Cimg%5C%E8%B7%9F%E5%8F%AF%E8%BE%BE%E5%88%86%E6%9E%90.jpg" alt="跟可达分析"></p><h4 id="Java中可以作为GCRoots的对象"><a href="#Java中可以作为GCRoots的对象" class="headerlink" title="Java中可以作为GCRoots的对象"></a>Java中可以作为GCRoots的对象</h4><p>1、虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象</p><p>2、方法区中的类静态属性引用的对象</p><p>3、方法区中常量引用的对象</p><p>4、本地方法栈中JNI（Native方法）引用的对象</p><p><img src="img%5Ccase.jpg" alt="case"></p><h2 id="三、GC三大算法"><a href="#三、GC三大算法" class="headerlink" title="三、GC三大算法"></a>三、GC三大算法</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2021/07/14/jvm/"/>
    <url>/2021/07/14/jvm/</url>
    
    <content type="html"><![CDATA[<h2 id="一、JVM体系结构概述"><a href="#一、JVM体系结构概述" class="headerlink" title="一、JVM体系结构概述"></a>一、JVM体系结构概述</h2><h3 id="一-、JVM体系结构"><a href="#一-、JVM体系结构" class="headerlink" title="(一)、JVM体系结构"></a>(一)、JVM体系结构</h3><p><img src="%5Cimg%5Cjvm.jpg" alt="jvm"></p><h4 id="1、类装载器ClassLoader"><a href="#1、类装载器ClassLoader" class="headerlink" title="1、类装载器ClassLoader"></a>1、类装载器ClassLoader</h4><h5 id="类装载器"><a href="#类装载器" class="headerlink" title="类装载器"></a>类装载器</h5><p>负责加载class文件，class文件在文件开头有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定</p><p>类加载是一个将class字节码文件实例化成Class对象并进行相关初始化的过程。<br>全小写的class是关键字用来定义类，首字母大写的Class它是所有class的类。</p><p><img src="%5Cimg%5C%E7%B1%BB%E5%8A%A0%E8%BD%BD.jpg" alt="类加载"></p><h5 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h5><p>1、启动类加载器（Bootstrap）C++</p><p>2、扩展类加载器（Extension）Java<br>第二层在JDK9版本中称为Platform ClassLoader即平台类加载器<br>JDK8及之前的加载器是Extension ClassLoader<br>System.getProperty(“java.ext.dirs”)</p><p>3、应用程序类加载器（AppClassLoader）Java也叫系统类加载器，加载当前应用的classpath的所有类</p><p>4、用户自定义加载器  Java.lang.ClassLoader的子类，用户可以定制类的加载方式</p><h5 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h5><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。 </p><p>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。 </p><blockquote><p>出问题往上怼，然后在一层一层去找</p></blockquote><p><img src="%5Cimg%5C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.jpg" alt="双亲委派"></p><p>好处：防止内存中出现多分同样的字节码（比如自定义一个java.lang.object类）</p><h4 id="2、Execution-Engine"><a href="#2、Execution-Engine" class="headerlink" title="2、Execution Engine"></a>2、Execution Engine</h4><p>Execution Engine执行引擎负责解释命令，提交操作系统执行。 </p><h4 id="3、Native-Interface本地接口"><a href="#3、Native-Interface本地接口" class="headerlink" title="3、Native Interface本地接口"></a>3、Native Interface本地接口</h4><p>本地接口的作用是融合不同的编程语言为 Java 所用</p><p>Java 诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraies</p><p>在企业级应用中已经比较少见。</p><h4 id="4、Native-Method-Stack"><a href="#4、Native-Method-Stack" class="headerlink" title="4、Native Method Stack"></a>4、Native Method Stack</h4><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p><h4 id="5、程序计数器（PC寄存器）"><a href="#5、程序计数器（PC寄存器）" class="headerlink" title="5、程序计数器（PC寄存器）"></a>5、程序计数器（PC寄存器）</h4><p>每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p><p>它是当前线程所执行的字节码的行号指示器</p><p>这块内存区域很小，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><h4 id="6、Method-Area-方法区"><a href="#6、Method-Area-方法区" class="headerlink" title="6、Method Area 方法区"></a>6、Method Area 方法区</h4><p>供各线程共享的运行时内存区域。<em><strong>它存储了每一个类的结构信息</strong></em><em><strong>（马甲）</strong></em>，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。</p><p><em><strong>But</strong></em>上面讲的是规范，在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)。</p><p><em><strong>实例变量存在堆内存中,和方法区无关</strong></em></p><h4 id="7、Stack栈"><a href="#7、Stack栈" class="headerlink" title="7、Stack栈"></a>7、Stack栈</h4><p>​    栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。</p><h5 id="栈存储什么"><a href="#栈存储什么" class="headerlink" title="栈存储什么?"></a>栈存储什么?</h5><p>栈帧中主要保存3 类数据：</p><p>本地变量（Local Variables）:输入参数和输出参数以及方法内的变量；</p><p>栈操作（Operand Stack）:记录出栈、入栈的操作；</p><p>栈帧数据（Frame Data）:包括类文件、方法等等。</p><h5 id="栈运行原理："><a href="#栈运行原理：" class="headerlink" title="栈运行原理："></a>栈运行原理：</h5><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，</p><p>遵循“先进后出”/“后进先出”原则。</p><p>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K~756K之间,与等于1Mb左右。</p><p><img src="%5Cimg%5C%E6%A0%88.jpg" alt="栈"></p><p>每执行一个方法都会产生一个栈帧，保存到栈(后进先出)的顶部，顶部栈就是当前的方法，该方法执行完毕 后会自动将此栈帧出栈。</p><p>Exception in thread “main” java.lang.StackOverflowError</p><h4 id="8、栈-堆-方法区的交互关系"><a href="#8、栈-堆-方法区的交互关系" class="headerlink" title="8、栈+堆+方法区的交互关系"></a>8、栈+堆+方法区的交互关系</h4><p><img src="%5Cimg%5C%E6%A0%88%EF%BC%8C%E5%A0%86%EF%BC%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%85%B3%E7%B3%BB.jpg" alt="栈，堆，方法区关系"></p><p>HotSpot是使用指针的方式来访问对象：<br>Java堆中会存放访问类元数据的地址，<br>reference存储的就直接是对象的地址</p><h2 id="二、堆体系结构概述"><a href="#二、堆体系结构概述" class="headerlink" title="二、堆体系结构概述"></a>二、堆体系结构概述</h2><h3 id="1、heap堆-Java7之前"><a href="#1、heap堆-Java7之前" class="headerlink" title="1、heap堆(Java7之前)"></a>1、heap堆(Java7之前)</h3><p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行。</p><p>java7堆内存逻辑上分为三部分：新生+养老+永久</p><p>java8堆内存逻辑上分为三部分：新生+养老+元空间</p><p>java7图如下：</p><p><img src="C:\Users\Administrator\Desktop\jvm\img\堆java7.jpg" alt="堆java7"></p><h3 id="2、Heap-堆"><a href="#2、Heap-堆" class="headerlink" title="2、Heap 堆"></a>2、Heap 堆</h3><p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分：</p><p><img src="%5Cimg%5C%E5%A0%86.jpg" alt="堆"></p><h5 id="新生区（大致理解，后有详细）"><a href="#新生区（大致理解，后有详细）" class="headerlink" title="新生区（大致理解，后有详细）"></a>新生区（大致理解，后有详细）</h5><p>1、新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命</p><p>2、新生区又分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace） ，所有的类都是在伊甸区被new出来的。幸存区有两个： 0区（Survivor 0 space）和1区（Survivor 1 space）</p><p>3、当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。</p><p>4、若幸存 0区也满了，再对该区进行垃圾回收，然后移动到 1 区。</p><p>5、那如果1 区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生MajorGC（FullGC），进行养老区的内存清理</p><p>6、若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。</p><h5 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h5><p>如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二：<br>（1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。<br>（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。</p><h5 id="新生区（详细）"><a href="#新生区（详细）" class="headerlink" title="新生区（详细）"></a>新生区（详细）</h5><blockquote><p><strong>口诀：GC之后有交换，谁空谁是to</strong></p></blockquote><p><img src="%5Cimg%5C%E6%96%B0%E7%94%9F%E5%8C%BA.jpg" alt="新生区"></p><p>新生代：老年代 = 1：2</p><p>伊甸区：幸存0：幸存1= 8：1：1</p><p>1：eden、SurvivorFrom 复制到 SurvivorTo，年龄+1<br>首先，当Eden区满的时候会触发第一次GC,把还活着的对象拷贝到SurvivorFrom区，当Eden区再次触发GC的时候会扫描Eden区和From区域,对这两个区域进行垃圾回收，经过这次回收后还存活的对象,则直接复制到To区域（如果有对象的年龄已经达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1</p><p>2：清空 eden、SurvivorFrom<br>然后，清空Eden和SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to</p><p>3：SurvivorTo和 SurvivorFrom 互换<br>最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区。部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代</p><p>4：大对象特殊情况<br>如果分配的新对象比较大Eden区放不下但Old区可以放下时，对象会被直接分配到Old区（即没有晋升这一过程，直接到老年代了）</p><p>![Sun HotSpot内存管理](\img\Sun HotSpot内存管理.jpg)</p><h5 id="新生区为啥需要Survivor区"><a href="#新生区为啥需要Survivor区" class="headerlink" title="新生区为啥需要Survivor区"></a>新生区为啥需要Survivor区</h5><p>1、不就是新生代到老年代么，直接Eden到Old不好了吗？为啥要这么复杂？</p><blockquote><p>想想如果没有Survivor区，Eden区每进行一次MinorGC存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次MinorGC没有消灭但其实也并不会蹦跶多久，或许第2次第3次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。<em><strong>所以Survivor的存在意义就是减少被送到老年代的对象，进而减少FullGC的发生</strong></em>。Survivor的预筛选保证只有经历15次MinorGC还能在新生代中存活的对象，才会被送到老年代。</p></blockquote><p>2、新生区为啥需要两个Survivor区，为什么8:1:1？</p><blockquote><p><em><strong>设置两个Survivor区最大的好处就是解决内存碎片化。</strong></em></p><p>假设Survivor如果只有一个区域会怎样？MinorGC执行后Eden区被清空了，存活的对象放到了Survivor区，而之前Survivor区中的对象，可能也有一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为Survivor有2个区域，所以每次MinorGC，会将之前Eden区和From区中的存活对象复制到To区域。第二次MinorGC时，From与To职责兑换，这时候会将Eden区和To区中的存活对象再复制到From区域，以此反复。这种机制最大的好处就是，整个过程中，永远有一个Survivorspace是空的，另一个非空的Survivorspace是无碎片的。那么，Survivor为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果Survivor区再细分下去，每一块的空间就会比较小，容易导致Survivor区满，两块Survivor区是经过权衡之后的最佳方案。</p></blockquote><h3 id="3、方法区"><a href="#3、方法区" class="headerlink" title="3、方法区"></a>3、方法区</h3><p>实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。</p><p>对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代(Parmanent Gen)” ，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区(相当于是一个接口interface)的一个实现.</p><p><img src="%5Cimg%5C%E6%96%B9%E6%B3%95%E5%8C%BA.jpg" alt="方法区"></p><h4 id="永久区Perm-java7之前有"><a href="#永久区Perm-java7之前有" class="headerlink" title="永久区Perm(java7之前有)"></a>永久区Perm(java7之前有)</h4><p>​    永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。</p><h4 id="元空间Metaspace-java8"><a href="#元空间Metaspace-java8" class="headerlink" title="元空间Metaspace (java8)"></a>元空间Metaspace (java8)</h4><p>   区别于永久代，元空间在本地内存中分配。在jdk8里，Prem区中的所有内容中字符串常量移至堆内存，其他内容包括类元信息、字段、静态属性、方法、常量等都移动至元空间内</p><h2 id="三、堆参数调优入门"><a href="#三、堆参数调优入门" class="headerlink" title="三、堆参数调优入门"></a>三、堆参数调优入门</h2><h3 id="1、JVM垃圾收集-Java-Garbage-Collection-本次均以JDK1-8-HotSpot为例"><a href="#1、JVM垃圾收集-Java-Garbage-Collection-本次均以JDK1-8-HotSpot为例" class="headerlink" title="1、JVM垃圾收集(Java Garbage Collection )本次均以JDK1.8+HotSpot为例"></a>1、JVM垃圾收集(Java Garbage Collection )本次均以JDK1.8+HotSpot为例</h3><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p>java7</p><p><img src="%5Cimg%5Cjava7.jpg" alt="java7"></p><p>java 8</p><p>JDK 1.8之后将最初的永久代取消了，由元空间取代。</p><p><img src="%5Cimg%5Cjava8.jpg" alt="java8"></p><p>在Java8中，永久代已经被移除，被一个称为元空间的区域所取代。元空间的本质和永久代类似。</p><h4 id="原空间跟永久代的区别"><a href="#原空间跟永久代的区别" class="headerlink" title="原空间跟永久代的区别"></a>原空间跟永久代的区别</h4><p>永久带使用的JVM的堆内存，但是java8以后的元空间并不在虚拟机中而是使用本机物理内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p><p><img src="%5Cimg%5C%E5%85%83%E7%A9%BA%E9%97%B4%E6%B0%B8%E4%B9%85%E4%BB%A3.jpg" alt="元空间永久代"></p><h3 id="2、堆内存调优简介"><a href="#2、堆内存调优简介" class="headerlink" title="2、堆内存调优简介"></a>2、堆内存调优简介</h3><p><img src="img%5C%E5%A0%86%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98.jpg" alt="堆内存调优"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JUC笔记</title>
    <link href="/2021/07/14/JUC%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/14/JUC%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Java多线程相关概念"><a href="#Java多线程相关概念" class="headerlink" title="Java多线程相关概念"></a>Java多线程相关概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务我们就可以看做是⼀个线程</p><p>⼀个进程会有1个或多个线程的</p><h3 id="线程有哪些状态？"><a href="#线程有哪些状态？" class="headerlink" title="线程有哪些状态？"></a>线程有哪些状态？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.State<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread which has not yet started.</span><br><span class="hljs-comment">     */</span><br>    NEW,(新建)<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="hljs-comment">     * state is executing in the Java virtual machine but it may</span><br><span class="hljs-comment">     * be waiting for other resources from the operating system</span><br><span class="hljs-comment">     * such as processor.</span><br><span class="hljs-comment">     */</span><br>    RUNNABLE,（准备就绪）<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="hljs-comment">     * A thread in the blocked state is waiting for a monitor lock</span><br><span class="hljs-comment">     * to enter a synchronized block/method or</span><br><span class="hljs-comment">     * reenter a synchronized block/method after calling</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125;.</span><br><span class="hljs-comment">     */</span><br>    BLOCKED,（阻塞）<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread.</span><br><span class="hljs-comment">     * A thread is in the waiting state due to calling one of the</span><br><span class="hljs-comment">     * following methods:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="hljs-comment">     * perform a particular action.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="hljs-comment">     * on an object is waiting for another thread to call</span><br><span class="hljs-comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="hljs-comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="hljs-comment">     * is waiting for a specified thread to terminate.</span><br><span class="hljs-comment">     */</span><br>    WAITING,（不见不散）<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread with a specified waiting time.</span><br><span class="hljs-comment">     * A thread is in the timed waiting state due to calling one of</span><br><span class="hljs-comment">     * the following methods with a specified positive waiting time:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     */</span><br>    TIMED_WAITING,（过时不候）<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a terminated thread.</span><br><span class="hljs-comment">     * The thread has completed execution.</span><br><span class="hljs-comment">     */</span><br>    TERMINATED;(终结)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>Monitor(监视器)，也就是我们平时所说的锁</p><p>Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</p><p>JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Object o = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (o)<br>    &#123;<br><br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br></code></pre></td></tr></table></figure><p>Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</p><h2 id="JUC是什么"><a href="#JUC是什么" class="headerlink" title="JUC是什么"></a>JUC是什么</h2><h3 id="java-util-concurrent在并发编程中使用的工具类"><a href="#java-util-concurrent在并发编程中使用的工具类" class="headerlink" title="java.util.concurrent在并发编程中使用的工具类"></a>java.util.concurrent在并发编程中使用的工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.concurrent    <br>java.util.concurrent.atomic    <br>java.util.concurrent.locks<br></code></pre></td></tr></table></figure><h3 id="wait-sleep的区别？"><a href="#wait-sleep的区别？" class="headerlink" title="wait/sleep的区别？"></a>wait/sleep的区别？</h3><p>wait放开手去睡，放开手里的锁<br>sleep握紧手去睡，醒了手里还有锁</p><h3 id="什么是并发？什么是并行？"><a href="#什么是并发？什么是并行？" class="headerlink" title="什么是并发？什么是并行？"></a>什么是并发？什么是并行？</h3><p>并发：同一时刻多个线程在访问同一个资源，多个线程对一个点<br>      例子：小米9今天上午10点，限量抢购<br>            春运抢票<br>            电商秒杀…<br>并行：多项工作一起执行，之后再汇总<br>      例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p><h3 id="进程-线程回顾"><a href="#进程-线程回顾" class="headerlink" title="进程/线程回顾"></a>进程/线程回顾</h3><h4 id="进程-线程是什么？"><a href="#进程-线程是什么？" class="headerlink" title="进程/线程是什么？"></a>进程/线程是什么？</h4><p>进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p><p>线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p><h4 id="进程-线程例子？"><a href="#进程-线程例子？" class="headerlink" title="进程/线程例子？"></a>进程/线程例子？</h4><p> 使用QQ，查看进程一定有一个QQ.exe的进程，我可以用qq和A文字聊天，和B视频聊天，给C传文件，给D发一段语言，QQ支持录入信息的搜索。</p><p>大四的时候写论文，用word写论文，同时用QQ音乐放音乐，同时用QQ聊天，多个进程。</p><p>word如没有保存，停电关机，再通电后打开word可以恢复之前未保存的文档，word也会检查你的拼写，两个线程：容灾备份，语法检查</p><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><h3 id="复习Synchronized"><a href="#复习Synchronized" class="headerlink" title="复习Synchronized"></a>复习Synchronized</h3><h4 id="多线程编程模板上"><a href="#多线程编程模板上" class="headerlink" title="多线程编程模板上"></a>多线程编程模板上</h4><p>1、线程 操作 资源类</p><p>2、高内聚低耦合</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>1、创建资源类</p><p>2、资源类里创建同步方法、同步代码块</p><h4 id="例子卖票程序"><a href="#例子卖票程序" class="headerlink" title="例子卖票程序"></a>例子卖票程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">50</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span>) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;卖出第：&quot;</span> + (number--) + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot; 还剩下：&quot;</span> + number);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaleTicketDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       Ticket ticket = <span class="hljs-keyword">new</span> Ticket();<br>       <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">51</span>; i++) ticket.sale();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects. </p><p>锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。</p><h4 id="Lock接口的实现"><a href="#Lock接口的实现" class="headerlink" title="Lock接口的实现"></a>Lock接口的实现</h4><p>ReentrantLock可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>     lock.lock();  <span class="hljs-comment">// block until condition holds</span><br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">// ... method body</span><br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       lock.unlock()<br>     &#125;<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="创建线程方式"><a href="#创建线程方式" class="headerlink" title="创建线程方式"></a>创建线程方式</h4><p>1、继承Thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaleTicket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span><br></code></pre></td></tr></table></figure><p>java是单继承，资源宝贵，要用接口方式 </p><p>2、Thread(Runnable target) </p><p>3、Thread(Runnable target, String name) </p><h4 id="实现runnable方法"><a href="#实现runnable方法" class="headerlink" title="实现runnable方法"></a>实现runnable方法</h4><p>1、新建类实现runnable接口</p><p>2、匿名内部类</p><p>3、lambda表达式</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span></span>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number=<span class="hljs-number">30</span>;<br> <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br> <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>&#123;<br>   lock.lock();<br>   <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span>(number &gt; <span class="hljs-number">0</span>) &#123;<br>     System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;卖出&quot;</span>+(number--)+<span class="hljs-string">&quot;\t 还剩number);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">   &#125; catch (Exception e) &#123;</span><br><span class="hljs-string">    e.printStackTrace();</span><br><span class="hljs-string">   &#125; finally &#123;</span><br><span class="hljs-string">    lock.unlock();</span><br><span class="hljs-string">   &#125;   </span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">                        </span><br><span class="hljs-string">public class SaleTicket </span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string"> public static void main(String[] args)</span><br><span class="hljs-string">   Ticket ticket = new Ticket();</span><br><span class="hljs-string"> new Thread(() -&gt; &#123;for (int i = 1; i &lt; 40; i++)ticket.sale();&#125;, &quot;</span>AA<span class="hljs-string">&quot;).start();</span><br><span class="hljs-string"> new Thread(() -&gt; &#123;for (int i = 1; i &lt; 40; i++)ticket.sale();&#125;, &quot;</span>BB<span class="hljs-string">&quot;).start();</span><br><span class="hljs-string"> new Thread(() -&gt; &#123;for (int i = 1; i &lt; 40; i++)ticket.sale();&#125;, &quot;</span>CC<span class="hljs-string">&quot;).start();</span><br><span class="hljs-string"> </span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">&#125;                        </span><br></code></pre></td></tr></table></figure><h2 id="多线程8锁案例"><a href="#多线程8锁案例" class="headerlink" title="多线程8锁案例"></a>多线程8锁案例</h2><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span>&#123;<br> <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSMS</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;------sendSMS&quot;</span>);<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendEmail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;------sendEmail&quot;</span>);<br> &#125; <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getHello</span><span class="hljs-params">()</span> </span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;------getHello&quot;</span>);<br> &#125; <br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 8锁</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> 1 标准访问，先打印短信还是邮件</span><br><span class="hljs-comment"> 2 停4秒在短信方法内，先打印短信还是邮件</span><br><span class="hljs-comment"> 3 新增普通的hello方法，是先打短信还是hello</span><br><span class="hljs-comment"> 4 现在有两部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> 5 两个静态同步方法，1部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> 6 两个静态同步方法，2部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> 7 1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> 8 1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> * ---------------------------------</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock_8</span></span><br><span class="hljs-class"></span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span><br><span class="hljs-function"> </span>&#123;<br> <br>   Phone phone = <span class="hljs-keyword">new</span> Phone();<br>   Phone phone2 = <span class="hljs-keyword">new</span> Phone();<br>   <br>   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>     phone.sendSMS();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>     e.printStackTrace();<br>    &#125;<br>   &#125;, <span class="hljs-string">&quot;AA&quot;</span>).start();<br>   <br>   Thread.sleep(<span class="hljs-number">100</span>);<br>   <br>   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>     phone.sendEmail();<br>     <span class="hljs-comment">//phone.getHello();</span><br>     <span class="hljs-comment">//phone2.sendEmail();</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>     e.printStackTrace();<br>    &#125;<br>   &#125;, <span class="hljs-string">&quot;BB&quot;</span>).start();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***  * 笔记</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  synchronized是实现同步的基础：Java中的每一个对象都可以作为锁。</span><br><span class="hljs-comment"> *  具体表现为以下3种形式。</span><br><span class="hljs-comment">    作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁；</span><br><span class="hljs-comment">    作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁；</span><br><span class="hljs-comment">    作用于代码块，对括号里配置的对象加锁。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *  1-2</span><br><span class="hljs-comment"> *  *  一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，</span><br><span class="hljs-comment"> *  *  其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法</span><br><span class="hljs-comment"> *  *  锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</span><br><span class="hljs-comment"> *  3-4</span><br><span class="hljs-comment"> *   *  加个普通方法后发现和同步锁无关</span><br><span class="hljs-comment"> *  *  换成两个对象后，不是同一把锁了，情况立刻变化。</span><br><span class="hljs-comment"> *  5-6</span><br><span class="hljs-comment"> *  都换成静态同步方法后，情况又变化</span><br><span class="hljs-comment"> *  若是普通同步方法，new     this,   具体的一部部手机,所有的普通同步方法用的都是同一把锁——实例对象本身，</span><br><span class="hljs-comment"> *  若是静态同步方法，static  Class ，唯一的一个模板</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  7-8</span><br><span class="hljs-comment"> *   *  当一个线程试图访问同步代码时它首先必须得到锁，退出或抛出异常时必须释放锁。</span><br><span class="hljs-comment"> *  *</span><br><span class="hljs-comment"> *  *  所有的普通同步方法用的都是同一把锁——实例对象本身，，就是new出来的具体实例对象本身</span><br><span class="hljs-comment"> *  *  也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁，</span><br><span class="hljs-comment"> *  *  可是别的实例对象的普通同步方法因为跟该实例对象的普通同步方法用的是不同的锁，所以不用等待该实例对象已获取锁的普通</span><br><span class="hljs-comment"> *  *  同步方法释放锁就可以获取他们自己的锁。</span><br><span class="hljs-comment"> *  *</span><br><span class="hljs-comment"> *  *  所有的静态同步方法用的也是同一把锁——类对象本身，就是我们说过的唯一模板Class</span><br><span class="hljs-comment"> *  *  具体实例对象this和唯一模板Class，这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的。</span><br><span class="hljs-comment"> *  *  但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁</span><br><span class="hljs-comment"> *  */</span><br></code></pre></td></tr></table></figure><p>结论</p><p>1、作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁；</p><p>2、作用于代码块，对括号里配置的对象加锁。</p><p>3、作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁；</p><p>注意：阿里手册第七条：能锁区块，就不要锁整个方法体，能用对象锁就不要类锁</p><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h3 id="案例：两个线程打印"><a href="#案例：两个线程打印" class="headerlink" title="案例：两个线程打印"></a>案例：两个线程打印</h3><h3 id="案例：四个线程打印"><a href="#案例：四个线程打印" class="headerlink" title="案例：四个线程打印"></a>案例：四个线程打印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">import</span> org.omg.IOP.Codec;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareData</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始值为零的一个变量</span><br><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>     <span class="hljs-comment">//判断</span><br>     <span class="hljs-keyword">while</span>(number!=<span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-keyword">this</span>.wait();<br>     &#125;<br>     <span class="hljs-comment">//干活</span><br>     ++number;<br>     System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; \t &quot;</span>+number);<br>     <span class="hljs-comment">//通知</span><br>     <span class="hljs-keyword">this</span>.notifyAll();;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>     <span class="hljs-comment">//判断</span><br>     <span class="hljs-keyword">while</span>(number!=<span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-keyword">this</span>.wait();<br>     &#125;<br>     <span class="hljs-comment">//干活</span><br>     --number;<br>     System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; \t &quot;</span>+number);<br>     <span class="hljs-comment">//通知</span><br>     <span class="hljs-keyword">this</span>.notifyAll();<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> *现在两个线程，</span><br><span class="hljs-comment"> * 可以操作初始值为零的一个变量，</span><br><span class="hljs-comment"> * 实现一个线程对该变量加1，一个线程对该变量减1，</span><br><span class="hljs-comment"> * 交替，来10轮。 </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * 笔记：Java里面如何进行工程级别的多线程编写</span><br><span class="hljs-comment"> * 1 多线程变成模板（套路）-----上</span><br><span class="hljs-comment"> *     1.1  线程    操作    资源类  </span><br><span class="hljs-comment"> *     1.2  高内聚  低耦合</span><br><span class="hljs-comment"> * 2 多线程变成模板（套路）-----下</span><br><span class="hljs-comment"> *     2.1  判断</span><br><span class="hljs-comment"> *     2.2  干活</span><br><span class="hljs-comment"> *     2.3  通知</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotifyWaitDemo</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     ShareData sd = <span class="hljs-keyword">new</span> ShareData();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            sd.increment();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();<br>     <br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            sd.decrement();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            sd.increment();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;C&quot;</span>).start();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            sd.decrement();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;D&quot;</span>).start();<br>     <br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * * </span><br><span class="hljs-comment"> * 2 多线程变成模板（套路）-----下</span><br><span class="hljs-comment"> *     2.1  判断</span><br><span class="hljs-comment"> *     2.2  干活</span><br><span class="hljs-comment"> *     2.3  通知</span><br><span class="hljs-comment"> * 3 防止虚假唤醒用while</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * */</span><br> <br></code></pre></td></tr></table></figure><p>注意：两个以上线程 判断条件if 要换成while 不然线程会出现错误，虚假唤醒</p><p>原因：在java多线程判断时，不能用if，程序出事出在了判断上面，<br>突然有一添加的线程进到if了，突然中断了交出控制权，<br>没有进行验证，而是直接走下去了，加了两次，甚至多次</p><p><img src="/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AFif%E9%97%AE%E9%A2%98.jpg" alt="多线程通讯if问题"></p><h3 id="java8新版实现"><a href="#java8新版实现" class="headerlink" title="java8新版实现"></a>java8新版实现</h3><p><img src="/img/lock%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%E5%9B%BE.jpg" alt="lock等待唤醒机制图"></p><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirCondition</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-comment">//1 判断</span><br>            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>)<br>            &#123;<br>                condition.await();<span class="hljs-comment">//this.wait();   //C A</span><br>            &#125;<br>            <span class="hljs-comment">//2 干活</span><br>            number++;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+number);<br>            <span class="hljs-comment">//3 通知</span><br>            condition.signalAll();<span class="hljs-comment">//this.notify();</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-comment">//1 判断</span><br>            <span class="hljs-keyword">while</span>(number == <span class="hljs-number">0</span>)<br>            &#123;<br>                condition.await();<span class="hljs-comment">//this.wait();</span><br>            &#125;<br>            <span class="hljs-comment">//2 干活</span><br>            number--;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+number);<br>            <span class="hljs-comment">//3 通知</span><br>            condition.signalAll();<span class="hljs-comment">//this.notify();</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-03-26 11:41</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 有一个初始值为零的变量，现有两个线程对该变量操作，</span><br><span class="hljs-comment"> * 实现一个线程对变量加1，实现一个线程对变量减1,交替来10次</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1 高内聚低耦合的前提下，线程       操作    资源类</span><br><span class="hljs-comment"> * 2 判断、干活、通知。</span><br><span class="hljs-comment"> * 3 防止虚假唤醒，用while</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProdConsumerDemo</span></span>&#123;<br>    <span class="hljs-keyword">static</span> Object objectLock = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        AirCondition airCondition = <span class="hljs-keyword">new</span> AirCondition();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//Thread.sleep(200);</span><br>                    airCondition.increment();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//Thread.sleep(300);</span><br>                    airCondition.decrement();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//Thread.sleep(400);</span><br>                    airCondition.increment();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;C&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//Thread.sleep(500);</span><br>                    airCondition.decrement();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;D&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/11/hello-world/"/>
    <url>/2021/07/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
