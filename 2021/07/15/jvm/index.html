

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>JVM - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JVM">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-07-15 03:39" pubdate>
        2021年7月15日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      37
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JVM</h1>
            
            <div class="markdown-body">
              <h2 id="一、JVM体系结构概述"><a href="#一、JVM体系结构概述" class="headerlink" title="一、JVM体系结构概述"></a>一、JVM体系结构概述</h2><h3 id="一-、JVM体系结构"><a href="#一-、JVM体系结构" class="headerlink" title="(一)、JVM体系结构"></a>(一)、JVM体系结构</h3><p><img src="%5Cimg%5Cjvm.jpg" srcset="/img/loading.gif" lazyload alt="jvm"></p>
<h4 id="1、类装载器ClassLoader"><a href="#1、类装载器ClassLoader" class="headerlink" title="1、类装载器ClassLoader"></a>1、类装载器ClassLoader</h4><h5 id="类装载器"><a href="#类装载器" class="headerlink" title="类装载器"></a>类装载器</h5><p>负责加载class文件，class文件在文件开头有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定</p>
<p>类加载是一个将class字节码文件实例化成Class对象并进行相关初始化的过程。<br>全小写的class是关键字用来定义类，首字母大写的Class它是所有class的类。</p>
<p><img src="%5Cimg%5C%E7%B1%BB%E5%8A%A0%E8%BD%BD.jpg" srcset="/img/loading.gif" lazyload alt="类加载"></p>
<h5 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h5><p>1、启动类加载器（Bootstrap）C++</p>
<p>2、扩展类加载器（Extension）Java<br>第二层在JDK9版本中称为Platform ClassLoader即平台类加载器<br>JDK8及之前的加载器是Extension ClassLoader<br>System.getProperty(“java.ext.dirs”)</p>
<p>3、应用程序类加载器（AppClassLoader）Java也叫系统类加载器，加载当前应用的classpath的所有类</p>
<p>4、用户自定义加载器  Java.lang.ClassLoader的子类，用户可以定制类的加载方式</p>
<h5 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h5><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。 </p>
<p>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。 </p>
<blockquote>
<p>出问题往上怼，然后在一层一层去找</p>
</blockquote>
<p><img src="%5Cimg%5C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.jpg" srcset="/img/loading.gif" lazyload alt="双亲委派"></p>
<p>好处：防止内存中出现多分同样的字节码（比如自定义一个java.lang.object类）</p>
<h4 id="2、Execution-Engine"><a href="#2、Execution-Engine" class="headerlink" title="2、Execution Engine"></a>2、Execution Engine</h4><p>Execution Engine执行引擎负责解释命令，提交操作系统执行。 </p>
<h4 id="3、Native-Interface本地接口"><a href="#3、Native-Interface本地接口" class="headerlink" title="3、Native Interface本地接口"></a>3、Native Interface本地接口</h4><p>本地接口的作用是融合不同的编程语言为 Java 所用</p>
<p>Java 诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraies</p>
<p>在企业级应用中已经比较少见。</p>
<h4 id="4、Native-Method-Stack"><a href="#4、Native-Method-Stack" class="headerlink" title="4、Native Method Stack"></a>4、Native Method Stack</h4><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p>
<h4 id="5、程序计数器（PC寄存器）"><a href="#5、程序计数器（PC寄存器）" class="headerlink" title="5、程序计数器（PC寄存器）"></a>5、程序计数器（PC寄存器）</h4><p>每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p>
<p>它是当前线程所执行的字节码的行号指示器</p>
<p>这块内存区域很小，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<h4 id="6、Method-Area-方法区"><a href="#6、Method-Area-方法区" class="headerlink" title="6、Method Area 方法区"></a>6、Method Area 方法区</h4><p>供各线程共享的运行时内存区域。<em><strong>它存储了每一个类的结构信息</strong></em><em><strong>（马甲）</strong></em>，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。</p>
<p><em><strong>But</strong></em>上面讲的是规范，在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)。</p>
<p><em><strong>实例变量存在堆内存中,和方法区无关</strong></em></p>
<h4 id="7、Stack栈"><a href="#7、Stack栈" class="headerlink" title="7、Stack栈"></a>7、Stack栈</h4><p>​    栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。</p>
<h5 id="栈存储什么"><a href="#栈存储什么" class="headerlink" title="栈存储什么?"></a>栈存储什么?</h5><p>栈帧中主要保存3 类数据：</p>
<p>本地变量（Local Variables）:输入参数和输出参数以及方法内的变量；</p>
<p>栈操作（Operand Stack）:记录出栈、入栈的操作；</p>
<p>栈帧数据（Frame Data）:包括类文件、方法等等。</p>
<h5 id="栈运行原理："><a href="#栈运行原理：" class="headerlink" title="栈运行原理："></a>栈运行原理：</h5><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，</p>
<p>遵循“先进后出”/“后进先出”原则。</p>
<p>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K~756K之间,与等于1Mb左右。</p>
<p><img src="%5Cimg%5C%E6%A0%88.jpg" srcset="/img/loading.gif" lazyload alt="栈"></p>
<p>每执行一个方法都会产生一个栈帧，保存到栈(后进先出)的顶部，顶部栈就是当前的方法，该方法执行完毕 后会自动将此栈帧出栈。</p>
<p>Exception in thread “main” java.lang.StackOverflowError</p>
<h4 id="8、栈-堆-方法区的交互关系"><a href="#8、栈-堆-方法区的交互关系" class="headerlink" title="8、栈+堆+方法区的交互关系"></a>8、栈+堆+方法区的交互关系</h4><p><img src="%5Cimg%5C%E6%A0%88%EF%BC%8C%E5%A0%86%EF%BC%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%85%B3%E7%B3%BB.jpg" srcset="/img/loading.gif" lazyload alt="栈，堆，方法区关系"></p>
<p>HotSpot是使用指针的方式来访问对象：<br>Java堆中会存放访问类元数据的地址，<br>reference存储的就直接是对象的地址</p>
<h2 id="二、堆体系结构概述"><a href="#二、堆体系结构概述" class="headerlink" title="二、堆体系结构概述"></a>二、堆体系结构概述</h2><h3 id="1、heap堆-Java7之前"><a href="#1、heap堆-Java7之前" class="headerlink" title="1、heap堆(Java7之前)"></a>1、heap堆(Java7之前)</h3><p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行。</p>
<p>java7堆内存逻辑上分为三部分：新生+养老+永久</p>
<p>java8堆内存逻辑上分为三部分：新生+养老+元空间</p>
<p>java7图如下：</p>
<p><img src="C:\Users\Administrator\Desktop\jvm\img\堆java7.jpg" srcset="/img/loading.gif" lazyload alt="堆java7"></p>
<h3 id="2、Heap-堆"><a href="#2、Heap-堆" class="headerlink" title="2、Heap 堆"></a>2、Heap 堆</h3><p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分：</p>
<p><img src="%5Cimg%5C%E5%A0%86.jpg" srcset="/img/loading.gif" lazyload alt="堆"></p>
<h5 id="新生区（大致理解，后有详细）"><a href="#新生区（大致理解，后有详细）" class="headerlink" title="新生区（大致理解，后有详细）"></a>新生区（大致理解，后有详细）</h5><p>1、新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命</p>
<p>2、新生区又分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace） ，所有的类都是在伊甸区被new出来的。幸存区有两个： 0区（Survivor 0 space）和1区（Survivor 1 space）</p>
<p>3、当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。</p>
<p>4、若幸存 0区也满了，再对该区进行垃圾回收，然后移动到 1 区。</p>
<p>5、那如果1 区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生MajorGC（FullGC），进行养老区的内存清理</p>
<p>6、若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。</p>
<h5 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h5><p>如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二：<br>（1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。<br>（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。</p>
<h5 id="新生区（详细）"><a href="#新生区（详细）" class="headerlink" title="新生区（详细）"></a>新生区（详细）</h5><blockquote>
<p><strong>口诀：GC之后有交换，谁空谁是to</strong></p>
</blockquote>
<p><img src="%5Cimg%5C%E6%96%B0%E7%94%9F%E5%8C%BA.jpg" srcset="/img/loading.gif" lazyload alt="新生区"></p>
<p>新生代：老年代 = 1：2</p>
<p>伊甸区：幸存0：幸存1= 8：1：1</p>
<p>1：eden、SurvivorFrom 复制到 SurvivorTo，年龄+1<br>首先，当Eden区满的时候会触发第一次GC,把还活着的对象拷贝到SurvivorFrom区，当Eden区再次触发GC的时候会扫描Eden区和From区域,对这两个区域进行垃圾回收，经过这次回收后还存活的对象,则直接复制到To区域（如果有对象的年龄已经达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1</p>
<p>2：清空 eden、SurvivorFrom<br>然后，清空Eden和SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to</p>
<p>3：SurvivorTo和 SurvivorFrom 互换<br>最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区。部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代</p>
<p>4：大对象特殊情况<br>如果分配的新对象比较大Eden区放不下但Old区可以放下时，对象会被直接分配到Old区（即没有晋升这一过程，直接到老年代了）</p>
<p>![Sun HotSpot内存管理](\img\Sun HotSpot内存管理.jpg)</p>
<h5 id="新生区为啥需要Survivor区"><a href="#新生区为啥需要Survivor区" class="headerlink" title="新生区为啥需要Survivor区"></a>新生区为啥需要Survivor区</h5><p>1、不就是新生代到老年代么，直接Eden到Old不好了吗？为啥要这么复杂？</p>
<blockquote>
<p>想想如果没有Survivor区，Eden区每进行一次MinorGC存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次MinorGC没有消灭但其实也并不会蹦跶多久，或许第2次第3次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。<em><strong>所以Survivor的存在意义就是减少被送到老年代的对象，进而减少FullGC的发生</strong></em>。Survivor的预筛选保证只有经历15次MinorGC还能在新生代中存活的对象，才会被送到老年代。</p>
</blockquote>
<p>2、新生区为啥需要两个Survivor区，为什么8:1:1？</p>
<blockquote>
<p><em><strong>设置两个Survivor区最大的好处就是解决内存碎片化。</strong></em></p>
<p>假设Survivor如果只有一个区域会怎样？MinorGC执行后Eden区被清空了，存活的对象放到了Survivor区，而之前Survivor区中的对象，可能也有一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为Survivor有2个区域，所以每次MinorGC，会将之前Eden区和From区中的存活对象复制到To区域。第二次MinorGC时，From与To职责兑换，这时候会将Eden区和To区中的存活对象再复制到From区域，以此反复。这种机制最大的好处就是，整个过程中，永远有一个Survivorspace是空的，另一个非空的Survivorspace是无碎片的。那么，Survivor为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果Survivor区再细分下去，每一块的空间就会比较小，容易导致Survivor区满，两块Survivor区是经过权衡之后的最佳方案。</p>
</blockquote>
<h3 id="3、方法区"><a href="#3、方法区" class="headerlink" title="3、方法区"></a>3、方法区</h3><p>实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。</p>
<p>对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代(Parmanent Gen)” ，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区(相当于是一个接口interface)的一个实现.</p>
<p><img src="%5Cimg%5C%E6%96%B9%E6%B3%95%E5%8C%BA.jpg" srcset="/img/loading.gif" lazyload alt="方法区"></p>
<h4 id="永久区Perm-java7之前有"><a href="#永久区Perm-java7之前有" class="headerlink" title="永久区Perm(java7之前有)"></a>永久区Perm(java7之前有)</h4><p>​    永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。</p>
<h4 id="元空间Metaspace-java8"><a href="#元空间Metaspace-java8" class="headerlink" title="元空间Metaspace (java8)"></a>元空间Metaspace (java8)</h4><p>   区别于永久代，元空间在本地内存中分配。在jdk8里，Prem区中的所有内容中字符串常量移至堆内存，其他内容包括类元信息、字段、静态属性、方法、常量等都移动至元空间内</p>
<h2 id="三、堆参数调优入门"><a href="#三、堆参数调优入门" class="headerlink" title="三、堆参数调优入门"></a>三、堆参数调优入门</h2><h3 id="1、JVM垃圾收集-Java-Garbage-Collection-本次均以JDK1-8-HotSpot为例"><a href="#1、JVM垃圾收集-Java-Garbage-Collection-本次均以JDK1-8-HotSpot为例" class="headerlink" title="1、JVM垃圾收集(Java Garbage Collection )本次均以JDK1.8+HotSpot为例"></a>1、JVM垃圾收集(Java Garbage Collection )本次均以JDK1.8+HotSpot为例</h3><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p>java7</p>
<p><img src="%5Cimg%5Cjava7.jpg" srcset="/img/loading.gif" lazyload alt="java7"></p>
<p>java 8</p>
<p>JDK 1.8之后将最初的永久代取消了，由元空间取代。</p>
<p><img src="%5Cimg%5Cjava8.jpg" srcset="/img/loading.gif" lazyload alt="java8"></p>
<p>在Java8中，永久代已经被移除，被一个称为元空间的区域所取代。元空间的本质和永久代类似。</p>
<h4 id="原空间跟永久代的区别"><a href="#原空间跟永久代的区别" class="headerlink" title="原空间跟永久代的区别"></a>原空间跟永久代的区别</h4><p>永久带使用的JVM的堆内存，但是java8以后的元空间并不在虚拟机中而是使用本机物理内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p>
<p><img src="%5Cimg%5C%E5%85%83%E7%A9%BA%E9%97%B4%E6%B0%B8%E4%B9%85%E4%BB%A3.jpg" srcset="/img/loading.gif" lazyload alt="元空间永久代"></p>
<h3 id="2、堆内存调优简介"><a href="#2、堆内存调优简介" class="headerlink" title="2、堆内存调优简介"></a>2、堆内存调优简介</h3><p><img src="img%5C%E5%A0%86%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98.jpg" srcset="/img/loading.gif" lazyload alt="堆内存调优"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/07/15/GC/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/14/JUC%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">JUC笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
