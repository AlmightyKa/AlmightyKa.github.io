

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>JUC笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JUC笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-07-14 10:00" pubdate>
        2021年7月14日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      133
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JUC笔记</h1>
            
            <div class="markdown-body">
              <h2 id="一、Java多线程相关概念"><a href="#一、Java多线程相关概念" class="headerlink" title="一、Java多线程相关概念"></a>一、Java多线程相关概念</h2><h3 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h3><p>是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源</p>
<h3 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h3><p>在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务我们就可以看做是⼀个线程</p>
<p>⼀个进程会有1个或多个线程的</p>
<h3 id="3、线程有哪些状态？"><a href="#3、线程有哪些状态？" class="headerlink" title="3、线程有哪些状态？"></a>3、线程有哪些状态？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.State<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread which has not yet started.</span><br><span class="hljs-comment">     */</span><br>    NEW,(新建)<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="hljs-comment">     * state is executing in the Java virtual machine but it may</span><br><span class="hljs-comment">     * be waiting for other resources from the operating system</span><br><span class="hljs-comment">     * such as processor.</span><br><span class="hljs-comment">     */</span><br>    RUNNABLE,（准备就绪）<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="hljs-comment">     * A thread in the blocked state is waiting for a monitor lock</span><br><span class="hljs-comment">     * to enter a synchronized block/method or</span><br><span class="hljs-comment">     * reenter a synchronized block/method after calling</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125;.</span><br><span class="hljs-comment">     */</span><br>    BLOCKED,（阻塞）<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread.</span><br><span class="hljs-comment">     * A thread is in the waiting state due to calling one of the</span><br><span class="hljs-comment">     * following methods:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="hljs-comment">     * perform a particular action.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="hljs-comment">     * on an object is waiting for another thread to call</span><br><span class="hljs-comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="hljs-comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="hljs-comment">     * is waiting for a specified thread to terminate.</span><br><span class="hljs-comment">     */</span><br>    WAITING,（不见不散）<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread with a specified waiting time.</span><br><span class="hljs-comment">     * A thread is in the timed waiting state due to calling one of</span><br><span class="hljs-comment">     * the following methods with a specified positive waiting time:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     */</span><br>    TIMED_WAITING,（过时不候）<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a terminated thread.</span><br><span class="hljs-comment">     * The thread has completed execution.</span><br><span class="hljs-comment">     */</span><br>    TERMINATED;(终结)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4、管程"><a href="#4、管程" class="headerlink" title="4、管程"></a>4、管程</h3><p>Monitor(监视器)，也就是我们平时所说的锁</p>
<p>Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</p>
<p>JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Object o = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (o)<br>    &#123;<br><br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br></code></pre></td></tr></table></figure>

<p>Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</p>
<h2 id="二、JUC是什么"><a href="#二、JUC是什么" class="headerlink" title="二、JUC是什么"></a>二、JUC是什么</h2><h3 id="1、java-util-concurrent在并发编程中使用的工具类"><a href="#1、java-util-concurrent在并发编程中使用的工具类" class="headerlink" title="1、java.util.concurrent在并发编程中使用的工具类"></a>1、java.util.concurrent在并发编程中使用的工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.concurrent    <br>java.util.concurrent.atomic    <br>java.util.concurrent.locks<br></code></pre></td></tr></table></figure>

<h3 id="2、wait-sleep的区别？"><a href="#2、wait-sleep的区别？" class="headerlink" title="2、wait/sleep的区别？"></a>2、wait/sleep的区别？</h3><p>wait放开手去睡，放开手里的锁<br>sleep握紧手去睡，醒了手里还有锁</p>
<h3 id="3、什么是并发？什么是并行？"><a href="#3、什么是并发？什么是并行？" class="headerlink" title="3、什么是并发？什么是并行？"></a>3、什么是并发？什么是并行？</h3><p>并发：同一时刻多个线程在访问同一个资源，多个线程对一个点<br>      例子：小米9今天上午10点，限量抢购<br>            春运抢票<br>            电商秒杀…<br>并行：多项工作一起执行，之后再汇总<br>      例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p>
<h3 id="4、进程-线程回顾"><a href="#4、进程-线程回顾" class="headerlink" title="4、进程/线程回顾"></a>4、进程/线程回顾</h3><h4 id="进程-线程是什么？"><a href="#进程-线程是什么？" class="headerlink" title="进程/线程是什么？"></a>进程/线程是什么？</h4><p>进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p>
<p>线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p>
<h4 id="进程-线程例子？"><a href="#进程-线程例子？" class="headerlink" title="进程/线程例子？"></a>进程/线程例子？</h4><p> 使用QQ，查看进程一定有一个QQ.exe的进程，我可以用qq和A文字聊天，和B视频聊天，给C传文件，给D发一段语言，QQ支持录入信息的搜索。</p>
<p>大四的时候写论文，用word写论文，同时用QQ音乐放音乐，同时用QQ聊天，多个进程。</p>
<p>word如没有保存，停电关机，再通电后打开word可以恢复之前未保存的文档，word也会检查你的拼写，两个线程：容灾备份，语法检查</p>
<h2 id="三、Lock接口"><a href="#三、Lock接口" class="headerlink" title="三、Lock接口"></a>三、Lock接口</h2><h3 id="1、复习Synchronized"><a href="#1、复习Synchronized" class="headerlink" title="1、复习Synchronized"></a>1、复习Synchronized</h3><h4 id="多线程编程模板上"><a href="#多线程编程模板上" class="headerlink" title="多线程编程模板上"></a>多线程编程模板上</h4><p>1、线程 操作 资源类</p>
<p>2、高内聚低耦合</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>1、创建资源类</p>
<p>2、资源类里创建同步方法、同步代码块</p>
<h4 id="例子卖票程序"><a href="#例子卖票程序" class="headerlink" title="例子卖票程序"></a>例子卖票程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">50</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span>) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;卖出第：&quot;</span> + (number--) + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot; 还剩下：&quot;</span> + number);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaleTicketDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       Ticket ticket = <span class="hljs-keyword">new</span> Ticket();<br>       <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">51</span>; i++) ticket.sale();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="2、Lock"><a href="#2、Lock" class="headerlink" title="2、Lock"></a>2、Lock</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects. </p>
<p>锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。</p>
<h4 id="Lock接口的实现"><a href="#Lock接口的实现" class="headerlink" title="Lock接口的实现"></a>Lock接口的实现</h4><p>ReentrantLock可重入锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>     lock.lock();  <span class="hljs-comment">// block until condition holds</span><br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">// ... method body</span><br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       lock.unlock()<br>     &#125;<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<h4 id="创建线程方式"><a href="#创建线程方式" class="headerlink" title="创建线程方式"></a>创建线程方式</h4><p>1、继承Thread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaleTicket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span><br></code></pre></td></tr></table></figure>

<p>java是单继承，资源宝贵，要用接口方式 </p>
<p>2、Thread(Runnable target) </p>
<p>3、Thread(Runnable target, String name) </p>
<h4 id="实现runnable方法"><a href="#实现runnable方法" class="headerlink" title="实现runnable方法"></a>实现runnable方法</h4><p>1、新建类实现runnable接口</p>
<p>2、匿名内部类</p>
<p>3、lambda表达式</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span></span>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number=<span class="hljs-number">30</span>;<br> <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br> <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>&#123;<br>   lock.lock();<br>   <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span>(number &gt; <span class="hljs-number">0</span>) &#123;<br>     System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;卖出&quot;</span>+(number--)+<span class="hljs-string">&quot;\t 还剩number);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">   &#125; catch (Exception e) &#123;</span><br><span class="hljs-string">    e.printStackTrace();</span><br><span class="hljs-string">   &#125; finally &#123;</span><br><span class="hljs-string">    lock.unlock();</span><br><span class="hljs-string">   &#125;   </span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">                        </span><br><span class="hljs-string">public class SaleTicket </span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string"> public static void main(String[] args)</span><br><span class="hljs-string">   Ticket ticket = new Ticket();</span><br><span class="hljs-string"> new Thread(() -&gt; &#123;for (int i = 1; i &lt; 40; i++)ticket.sale();&#125;, &quot;</span>AA<span class="hljs-string">&quot;).start();</span><br><span class="hljs-string"> new Thread(() -&gt; &#123;for (int i = 1; i &lt; 40; i++)ticket.sale();&#125;, &quot;</span>BB<span class="hljs-string">&quot;).start();</span><br><span class="hljs-string"> new Thread(() -&gt; &#123;for (int i = 1; i &lt; 40; i++)ticket.sale();&#125;, &quot;</span>CC<span class="hljs-string">&quot;).start();</span><br><span class="hljs-string"> </span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">&#125;                        </span><br></code></pre></td></tr></table></figure>

<h2 id="四、多线程8锁案例"><a href="#四、多线程8锁案例" class="headerlink" title="四、多线程8锁案例"></a>四、多线程8锁案例</h2><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span>&#123;<br> <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSMS</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;------sendSMS&quot;</span>);<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendEmail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;------sendEmail&quot;</span>);<br> &#125; <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getHello</span><span class="hljs-params">()</span> </span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;------getHello&quot;</span>);<br> &#125; <br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 8锁</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> 1 标准访问，先打印短信还是邮件</span><br><span class="hljs-comment"> 2 停4秒在短信方法内，先打印短信还是邮件</span><br><span class="hljs-comment"> 3 新增普通的hello方法，是先打短信还是hello</span><br><span class="hljs-comment"> 4 现在有两部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> 5 两个静态同步方法，1部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> 6 两个静态同步方法，2部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> 7 1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> 8 1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件</span><br><span class="hljs-comment"> * ---------------------------------</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock_8</span></span><br><span class="hljs-class"></span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span><br><span class="hljs-function"> </span>&#123;<br> <br>   Phone phone = <span class="hljs-keyword">new</span> Phone();<br>   Phone phone2 = <span class="hljs-keyword">new</span> Phone();<br>   <br>   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>     phone.sendSMS();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>     e.printStackTrace();<br>    &#125;<br>   &#125;, <span class="hljs-string">&quot;AA&quot;</span>).start();<br>   <br>   Thread.sleep(<span class="hljs-number">100</span>);<br>   <br>   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>     phone.sendEmail();<br>     <span class="hljs-comment">//phone.getHello();</span><br>     <span class="hljs-comment">//phone2.sendEmail();</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>     e.printStackTrace();<br>    &#125;<br>   &#125;, <span class="hljs-string">&quot;BB&quot;</span>).start();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***  * 笔记</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  synchronized是实现同步的基础：Java中的每一个对象都可以作为锁。</span><br><span class="hljs-comment"> *  具体表现为以下3种形式。</span><br><span class="hljs-comment">    作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁；</span><br><span class="hljs-comment">    作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁；</span><br><span class="hljs-comment">    作用于代码块，对括号里配置的对象加锁。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *  1-2</span><br><span class="hljs-comment"> *  *  一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，</span><br><span class="hljs-comment"> *  *  其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法</span><br><span class="hljs-comment"> *  *  锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</span><br><span class="hljs-comment"> *  3-4</span><br><span class="hljs-comment"> *   *  加个普通方法后发现和同步锁无关</span><br><span class="hljs-comment"> *  *  换成两个对象后，不是同一把锁了，情况立刻变化。</span><br><span class="hljs-comment"> *  5-6</span><br><span class="hljs-comment"> *  都换成静态同步方法后，情况又变化</span><br><span class="hljs-comment"> *  若是普通同步方法，new     this,   具体的一部部手机,所有的普通同步方法用的都是同一把锁——实例对象本身，</span><br><span class="hljs-comment"> *  若是静态同步方法，static  Class ，唯一的一个模板</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  7-8</span><br><span class="hljs-comment"> *   *  当一个线程试图访问同步代码时它首先必须得到锁，退出或抛出异常时必须释放锁。</span><br><span class="hljs-comment"> *  *</span><br><span class="hljs-comment"> *  *  所有的普通同步方法用的都是同一把锁——实例对象本身，，就是new出来的具体实例对象本身</span><br><span class="hljs-comment"> *  *  也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁，</span><br><span class="hljs-comment"> *  *  可是别的实例对象的普通同步方法因为跟该实例对象的普通同步方法用的是不同的锁，所以不用等待该实例对象已获取锁的普通</span><br><span class="hljs-comment"> *  *  同步方法释放锁就可以获取他们自己的锁。</span><br><span class="hljs-comment"> *  *</span><br><span class="hljs-comment"> *  *  所有的静态同步方法用的也是同一把锁——类对象本身，就是我们说过的唯一模板Class</span><br><span class="hljs-comment"> *  *  具体实例对象this和唯一模板Class，这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的。</span><br><span class="hljs-comment"> *  *  但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁</span><br><span class="hljs-comment"> *  */</span><br></code></pre></td></tr></table></figure>

<p>结论</p>
<p>1、作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁；</p>
<p>2、作用于代码块，对括号里配置的对象加锁。</p>
<p>3、作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁；</p>
<p>注意：阿里手册第七条：能锁区块，就不要锁整个方法体，能用对象锁就不要类锁</p>
<h2 id="五、线程间通信"><a href="#五、线程间通信" class="headerlink" title="五、线程间通信"></a>五、线程间通信</h2><h3 id="1、案例：两个线程打印"><a href="#1、案例：两个线程打印" class="headerlink" title="1、案例：两个线程打印"></a>1、案例：两个线程打印</h3><h3 id="2、案例：四个线程打印"><a href="#2、案例：四个线程打印" class="headerlink" title="2、案例：四个线程打印"></a>2、案例：四个线程打印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">import</span> org.omg.IOP.Codec;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareData</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始值为零的一个变量</span><br><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>     <span class="hljs-comment">//判断</span><br>     <span class="hljs-keyword">while</span>(number!=<span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-keyword">this</span>.wait();<br>     &#125;<br>     <span class="hljs-comment">//干活</span><br>     ++number;<br>     System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; \t &quot;</span>+number);<br>     <span class="hljs-comment">//通知</span><br>     <span class="hljs-keyword">this</span>.notifyAll();;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>     <span class="hljs-comment">//判断</span><br>     <span class="hljs-keyword">while</span>(number!=<span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-keyword">this</span>.wait();<br>     &#125;<br>     <span class="hljs-comment">//干活</span><br>     --number;<br>     System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; \t &quot;</span>+number);<br>     <span class="hljs-comment">//通知</span><br>     <span class="hljs-keyword">this</span>.notifyAll();<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> *现在两个线程，</span><br><span class="hljs-comment"> * 可以操作初始值为零的一个变量，</span><br><span class="hljs-comment"> * 实现一个线程对该变量加1，一个线程对该变量减1，</span><br><span class="hljs-comment"> * 交替，来10轮。 </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * 笔记：Java里面如何进行工程级别的多线程编写</span><br><span class="hljs-comment"> * 1 多线程变成模板（套路）-----上</span><br><span class="hljs-comment"> *     1.1  线程    操作    资源类  </span><br><span class="hljs-comment"> *     1.2  高内聚  低耦合</span><br><span class="hljs-comment"> * 2 多线程变成模板（套路）-----下</span><br><span class="hljs-comment"> *     2.1  判断</span><br><span class="hljs-comment"> *     2.2  干活</span><br><span class="hljs-comment"> *     2.3  通知</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotifyWaitDemo</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     ShareData sd = <span class="hljs-keyword">new</span> ShareData();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            sd.increment();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();<br>     <br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            sd.decrement();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            sd.increment();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;C&quot;</span>).start();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            sd.decrement();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;D&quot;</span>).start();<br>     <br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * * </span><br><span class="hljs-comment"> * 2 多线程变成模板（套路）-----下</span><br><span class="hljs-comment"> *     2.1  判断</span><br><span class="hljs-comment"> *     2.2  干活</span><br><span class="hljs-comment"> *     2.3  通知</span><br><span class="hljs-comment"> * 3 防止虚假唤醒用while</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * */</span><br> <br></code></pre></td></tr></table></figure>

<p>注意：两个以上线程 判断条件if 要换成while 不然线程会出现错误，虚假唤醒</p>
<p>原因：在java多线程判断时，不能用if，程序出事出在了判断上面，<br>突然有一添加的线程进到if了，突然中断了交出控制权，<br>没有进行验证，而是直接走下去了，加了两次，甚至多次</p>
<p><img src="/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AFif%E9%97%AE%E9%A2%98.jpg" srcset="/img/loading.gif" lazyload alt="多线程通讯if问题"></p>
<h3 id="3、java8新版实现"><a href="#3、java8新版实现" class="headerlink" title="3、java8新版实现"></a>3、java8新版实现</h3><p><img src="/img/lock%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%E5%9B%BE.jpg" srcset="/img/loading.gif" lazyload alt="lock等待唤醒机制图"></p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirCondition</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-comment">//1 判断</span><br>            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>)<br>            &#123;<br>                condition.await();<span class="hljs-comment">//this.wait();   //C A</span><br>            &#125;<br>            <span class="hljs-comment">//2 干活</span><br>            number++;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+number);<br>            <span class="hljs-comment">//3 通知</span><br>            condition.signalAll();<span class="hljs-comment">//this.notify();</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-comment">//1 判断</span><br>            <span class="hljs-keyword">while</span>(number == <span class="hljs-number">0</span>)<br>            &#123;<br>                condition.await();<span class="hljs-comment">//this.wait();</span><br>            &#125;<br>            <span class="hljs-comment">//2 干活</span><br>            number--;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+number);<br>            <span class="hljs-comment">//3 通知</span><br>            condition.signalAll();<span class="hljs-comment">//this.notify();</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-03-26 11:41</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 有一个初始值为零的变量，现有两个线程对该变量操作，</span><br><span class="hljs-comment"> * 实现一个线程对变量加1，实现一个线程对变量减1,交替来10次</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1 高内聚低耦合的前提下，线程       操作    资源类</span><br><span class="hljs-comment"> * 2 判断、干活、通知。</span><br><span class="hljs-comment"> * 3 防止虚假唤醒，用while</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProdConsumerDemo</span></span>&#123;<br>    <span class="hljs-keyword">static</span> Object objectLock = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        AirCondition airCondition = <span class="hljs-keyword">new</span> AirCondition();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//Thread.sleep(200);</span><br>                    airCondition.increment();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//Thread.sleep(300);</span><br>                    airCondition.decrement();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//Thread.sleep(400);</span><br>                    airCondition.increment();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;C&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//Thread.sleep(500);</span><br>                    airCondition.decrement();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;D&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4、死锁"><a href="#4、死锁" class="headerlink" title="4、死锁"></a>4、死锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLock</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> Object A = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">static</span> Object B = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (A) &#123;<br>                System.out.println(<span class="hljs-string">&quot;持有锁A，希望锁B&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (B) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;获得B&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (B) &#123;<br>                System.out.println(<span class="hljs-string">&quot;持有锁B，希望锁A&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (A) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;获得A&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="调试并发问题的一些技巧"><a href="#调试并发问题的一些技巧" class="headerlink" title="调试并发问题的一些技巧"></a>调试并发问题的一些技巧</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">jps -l  查看进程<br>jstack [进程id]   打印错误<br>jconsole  java控制台<br></code></pre></td></tr></table></figure>

<h2 id="六、NotSafeDemo"><a href="#六、NotSafeDemo" class="headerlink" title="六、NotSafeDemo"></a>六、NotSafeDemo</h2><h3 id="1、集合类线程不安全"><a href="#1、集合类线程不安全" class="headerlink" title="1、集合类线程不安全"></a>1、集合类线程不安全</h3><blockquote>
<p>java.util.ConcurrentModificationException</p>
<p>ArrayList在迭代的时候如果同时对其进行修改就会<br>抛出java.util.ConcurrentModificationException异常<br>并发修改异常(system.out.print())</p>
</blockquote>
<h3 id="2、ArrayList"><a href="#2、ArrayList" class="headerlink" title="2、ArrayList"></a>2、ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//看ArrayList的源码</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3、Vector"><a href="#3、Vector" class="headerlink" title="3、Vector"></a>3、Vector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br><span class="hljs-comment">//看Vector的源码</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    modCount++;<br>    ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);<br>    elementData[elementCount++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-comment">//有synchronized线程安全</span><br></code></pre></td></tr></table></figure>

<h3 id="4、Collections工具类"><a href="#4、Collections工具类" class="headerlink" title="4、Collections工具类"></a>4、Collections工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br><span class="hljs-comment">//Collections提供了方法synchronizedList保证list是同步线程安全的</span><br><br>Map&lt;Object, Object&gt; objectObjectMap = Collections.synchronizedMap(<span class="hljs-keyword">new</span> HashMap&lt;&gt;());<span class="hljs-comment">//map</span><br><br>Set&lt;Object&gt; objects = Collections.synchronizedSet(<span class="hljs-keyword">new</span> HashSet&lt;&gt;());<span class="hljs-comment">//set</span><br></code></pre></td></tr></table></figure>

<h3 id="5、CopyOnWrite"><a href="#5、CopyOnWrite" class="headerlink" title="5、CopyOnWrite"></a>5、CopyOnWrite</h3><h4 id="CopyOnWriteArrayList定义"><a href="#CopyOnWriteArrayList定义" class="headerlink" title="CopyOnWriteArrayList定义"></a>CopyOnWriteArrayList定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<span class="hljs-comment">//list</span><br>Map map = <span class="hljs-keyword">new</span> ConcurrentHashMap();<span class="hljs-comment">//map</span><br>Set set = <span class="hljs-keyword">new</span> CopyOnWriteArraySet();<span class="hljs-comment">//set</span><br></code></pre></td></tr></table></figure>

<p>A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.<br>CopyOnWriteArrayList是arraylist的一种线程安全变体，<br>其中所有可变操作（add、set等）都是通过生成底层数组的新副本来实现的。</p>
<h4 id="CopyOnWrite理论"><a href="#CopyOnWrite理论" class="headerlink" title="CopyOnWrite理论"></a>CopyOnWrite理论</h4><p>例如 ：名单签到</p>
<p><img src="/img/copyonwrite.jpg" srcset="/img/loading.gif" lazyload alt="copyonwrite"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Appends the specified element to the end of this list.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> e element to be appended to this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; (as specified by &#123;<span class="hljs-doctag">@link</span> Collection#add&#125;)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-keyword">int</span> len = elements.length;<br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure>

<blockquote>
<p>CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，<br>而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。<br>添加元素后，再将原容器的引用指向新的容器setArray(newElements)。<br>这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。<br>所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
</blockquote>
<h4 id="扩展类比"><a href="#扩展类比" class="headerlink" title="扩展类比"></a>扩展类比</h4><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<span class="hljs-comment">//线程不安全</span><br> <br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;&gt;();<span class="hljs-comment">//线程安全</span><br> <br><span class="hljs-comment">/*HashSet底层数据结构是什么？</span><br><span class="hljs-comment">HashMap  ?</span><br><span class="hljs-comment">但HashSet的add是放一个值，而HashMap是放K、V键值对</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;<br>    map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>&#125;<br> <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;<br>&#125;<br> <br> <br></code></pre></td></tr></table></figure>

<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//线程不安全</span><br> <br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<span class="hljs-comment">//线程安全</span><br> <br></code></pre></td></tr></table></figure>

<h2 id="七、线程间定制化调用通信"><a href="#七、线程间定制化调用通信" class="headerlink" title="七、线程间定制化调用通信"></a>七、线程间定制化调用通信</h2><p>需求：</p>
<p>多线程之间按顺序调用，实现A-&gt;B-&gt;C </p>
<p>三个线程启动，要求如下：</p>
<p>AA打印5次，BB打印10次，CC打印15次   ，接着</p>
<p>AA打印5次，BB打印10次，CC打印15次……来10轮 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareResource</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;<span class="hljs-comment">//1:A 2:B 3:C </span><br>  <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>  <span class="hljs-keyword">private</span> Condition c1 = lock.newCondition();<br>  <span class="hljs-keyword">private</span> Condition c2 = lock.newCondition();<br>  <span class="hljs-keyword">private</span> Condition c3 = lock.newCondition();<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print5</span><span class="hljs-params">(<span class="hljs-keyword">int</span> totalLoopNumber)</span></span>&#123;<br>     lock.lock();<br>     <span class="hljs-keyword">try</span>&#123;<br>       <span class="hljs-comment">//1 判断</span><br>       <span class="hljs-keyword">while</span>(number != <span class="hljs-number">1</span>)&#123;<br>          <span class="hljs-comment">//A 就要停止</span><br>          c1.await();<br>       &#125;<br>       <span class="hljs-comment">//2 干活</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span>; i++)&#123;<br>          System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+i+<span class="hljs-string">&quot;\t totalLoopNumber: &quot;</span>+totalLoopNumber);<br>       &#125;<br>       <span class="hljs-comment">//3 通知</span><br>       number = <span class="hljs-number">2</span>;<br>       c2.signal();<br>     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>       e.printStackTrace();<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       lock.unlock();<br>     &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print10</span><span class="hljs-params">(<span class="hljs-keyword">int</span> totalLoopNumber)</span></span>&#123;<br>     lock.lock();<br>     <span class="hljs-keyword">try</span>&#123;<br>       <span class="hljs-comment">//1 判断</span><br>       <span class="hljs-keyword">while</span>(number != <span class="hljs-number">2</span>)&#123;<br>          <span class="hljs-comment">//A 就要停止</span><br>          c2.await();<br>       &#125;<br>       <span class="hljs-comment">//2 干活</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++)&#123;<br>          System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+i+<span class="hljs-string">&quot;\t totalLoopNumber: &quot;</span>+totalLoopNumber);<br>       &#125;<br>       <span class="hljs-comment">//3 通知</span><br>       number = <span class="hljs-number">3</span>;<br>       c3.signal();<br>     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>       e.printStackTrace();<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       lock.unlock();<br>     &#125;<br>  &#125;  <br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print15</span><span class="hljs-params">(<span class="hljs-keyword">int</span> totalLoopNumber)</span></span>&#123;<br>     lock.lock();<br>     <span class="hljs-keyword">try</span>&#123;<br>       <span class="hljs-comment">//1 判断</span><br>       <span class="hljs-keyword">while</span>(number != <span class="hljs-number">3</span>)&#123;<br>          <span class="hljs-comment">//A 就要停止</span><br>          c3.await();<br>       &#125;<br>       <span class="hljs-comment">//2 干活</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">15</span>; i++)&#123;<br>          System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+i+<span class="hljs-string">&quot;\t totalLoopNumber: &quot;</span>+totalLoopNumber);<br>       &#125;<br>       <span class="hljs-comment">//3 通知</span><br>       number = <span class="hljs-number">1</span>;<br>       c1.signal();<br>     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>       e.printStackTrace();<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>       lock.unlock();<br>     &#125;<br>  &#125;  <br>&#125;<br> <br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadOrderAccess</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     ShareResource sr = <span class="hljs-keyword">new</span> ShareResource();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++)&#123;<br>          sr.print5(i);<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;AA&quot;</span>).start();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++)&#123;<br>          sr.print10(i);<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;BB&quot;</span>).start();<br>     <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++)&#123;<br>          sr.print15(i);<br>       &#125;<br>     &#125;, <span class="hljs-string">&quot;CC&quot;</span>).start();      <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="八、Callable接口"><a href="#八、Callable接口" class="headerlink" title="八、Callable接口"></a>八、Callable接口</h2><h3 id="1、获得多线程的方法几种？"><a href="#1、获得多线程的方法几种？" class="headerlink" title="1、获得多线程的方法几种？"></a>1、获得多线程的方法几种？</h3><blockquote>
<p> 传统的是继承thread类和实现runnable接口，<br>java5以后又有实现callable接口和java的线程池获得</p>
</blockquote>
<h3 id="2、Callable接口是什么"><a href="#2、Callable接口是什么" class="headerlink" title="2、Callable接口是什么"></a>2、Callable接口是什么</h3><p>函数式接口 （支持lambda表达式）</p>
<p>java.util.concurrent</p>
<h3 id="3、与runnable对比"><a href="#3、与runnable对比" class="headerlink" title="3、与runnable对比"></a>3、与runnable对比</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//创建新类MyThread实现runnable接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br> <br> &#125;<br>&#125;<br><span class="hljs-comment">//新类MyThread2实现callable接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br> &#125; <br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h4 id="callable接口与runnable接口的区别？"><a href="#callable接口与runnable接口的区别？" class="headerlink" title="callable接口与runnable接口的区别？"></a>callable接口与runnable接口的区别？</h4><p>(1)是否有返回值<br>(2)是否抛异常<br>(3)落地方法不一样，一个是run，一个是call</p>
<h3 id="4、如何使用callable接口"><a href="#4、如何使用callable接口" class="headerlink" title="4、如何使用callable接口"></a>4、如何使用callable接口</h3><h4 id="直接替换runnable是否可行？"><a href="#直接替换runnable是否可行？" class="headerlink" title="直接替换runnable是否可行？"></a>直接替换runnable是否可行？</h4><p><img src="/img/callable1.jpg" srcset="/img/loading.gif" lazyload alt="callable1"></p>
<h4 id="认识不同的人找中间人"><a href="#认识不同的人找中间人" class="headerlink" title="认识不同的人找中间人"></a>认识不同的人找中间人</h4><p><img src="/img/callable2.jpg" srcset="/img/loading.gif" lazyload alt="callable2"></p>
<h3 id="5、FutureTask"><a href="#5、FutureTask" class="headerlink" title="5、FutureTask"></a>5、FutureTask</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p>未来的任务，用它就干一件事，异步调用<br>main方法就像一个冰糖葫芦，一个个方法由main串起来。<br>但解决不了一个问题：正常调用挂起堵塞问题</p>
<p> ￼<img src="/img/futuretask.jpg" srcset="/img/loading.gif" lazyload alt="futuretask"><br>例子：<br>4个同学，A算1+20,B算21+30,C算31*到40,D算41+50，由于C的计算量有点大，<br>FutureTask单起个线程给C计算，先汇总ABD，最后等C计算完了再汇总C，拿到最终结果</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote>
<p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，<br>当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。</p>
<p>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p>
<p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，<br>就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。 </p>
<p>只计算一次<br><strong>get方法放到最后</strong></p>
</blockquote>
<p>​    ```</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;come in callable&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableDemo</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//FutureTask&lt;Integer&gt; futureTask = new FutureTask(new MyThread2());</span><br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;  come in callable&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;<br>        &#125;);<br>        FutureTask&lt;Integer&gt; futureTask2 = <span class="hljs-keyword">new</span> FutureTask(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;  come in callable&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2048</span>;<br>        &#125;);<br><br>        <span class="hljs-keyword">new</span> Thread(futureTask,<span class="hljs-string">&quot;zhang3&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(futureTask2,<span class="hljs-string">&quot;li4&quot;</span>).start();<br><br>        <span class="hljs-comment">//System.out.println(futureTask.get());</span><br>        <span class="hljs-comment">//System.out.println(futureTask2.get());</span><br>        <span class="hljs-comment">//1、一般放在程序后面，直接获取结果</span><br>        <span class="hljs-comment">//2、只会计算结果一次</span><br><br>        <span class="hljs-keyword">while</span>(!futureTask.isDone())&#123;<br>            System.out.println(<span class="hljs-string">&quot;***wait&quot;</span>);<br>        &#125;<br>        System.out.println(futureTask.get());<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; come over&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="九、ReentrantReadWriteLock读写锁"><a href="#九、ReentrantReadWriteLock读写锁" class="headerlink" title="九、ReentrantReadWriteLock读写锁"></a>九、ReentrantReadWriteLock读写锁</h2><p>案例：5个线程读，5个线程写入，操作同一个资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache</span> //资源类</span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">volatile</span> Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock readWriteLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String key,String value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        readWriteLock.writeLock().lock();<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 准备写入&quot;</span>);<br>            map.put(key,value);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 完成写入-----：&quot;</span>+value);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            readWriteLock.writeLock().unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        readWriteLock.readLock().lock();<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 准备读取&quot;</span>);<br>            String result = map.get(key);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 完成读取-----：&quot;</span>+result);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            readWriteLock.readLock().unlock();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 读写锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 对于同一个资源，我们涉及多线程的操作，有读，有写，交替进行。</span><br><span class="hljs-comment"> * 为了保证读写的数据一致性。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 读 读 可共享</span><br><span class="hljs-comment"> * 读 写 不共享</span><br><span class="hljs-comment"> * 写 写 不共享</span><br><span class="hljs-comment"> * 读的时候希望高并发同时进行，可以共享，可以多个线程同时操作进行中.....</span><br><span class="hljs-comment"> * 写的时候为了保证数据一致性，需要独占排它。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 题目：5个线程读，5个线程写入，操作同一个资源</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1 不加锁                不可以，写的时候原子性被破坏</span><br><span class="hljs-comment"> * 2 加ReentrantLock锁     写控制了，但是没有并发度，并发性能不好</span><br><span class="hljs-comment"> * 3 加读写锁               规范写入，写唯一，读并发</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockDemo</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        MyCache myCache = <span class="hljs-keyword">new</span> MyCache();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tmpI = i;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                myCache.write(tmpI+<span class="hljs-string">&quot;&quot;</span>,tmpI+<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tmpI = i;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                myCache.read(tmpI+<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="十、JUC强大的辅助类讲解"><a href="#十、JUC强大的辅助类讲解" class="headerlink" title="十、JUC强大的辅助类讲解"></a>十、JUC强大的辅助类讲解</h2><h3 id="1、CountDownLatch减少计数"><a href="#1、CountDownLatch减少计数" class="headerlink" title="1、CountDownLatch减少计数"></a>1、CountDownLatch减少计数</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</p>
<p>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</p>
<p>当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> *  *让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</span><br><span class="hljs-comment"> * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</span><br><span class="hljs-comment"> * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 解释：6个同学陆续离开教室后值班同学才可以关门。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatchDemo</span></span><br><span class="hljs-class"></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function">   </span>&#123;<br>         CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">6</span>);<br>       <br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">6</span>; i++) <span class="hljs-comment">//6个上自习的同学，各自离开教室的时间不一致</span><br>       &#123;<br>          <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>              System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 号同学离开教室&quot;</span>);<br>              countDownLatch.countDown();<br>          &#125;, String.valueOf(i)).start();<br>       &#125;<br>       countDownLatch.await();<br>       System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t****** 班长关门走人，main线程是班长&quot;</span>);<br>          <br>   &#125;<br> <br> <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2、CyclicBarrier循环栅栏"><a href="#2、CyclicBarrier循环栅栏" class="headerlink" title="2、CyclicBarrier循环栅栏"></a>2、CyclicBarrier循环栅栏</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>CyclicBarrier的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。线程进入屏障通过CyclicBarrier的await()方法。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.BrokenBarrierException;<br><span class="hljs-keyword">import</span> java.util.concurrent.CyclicBarrier; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * CyclicBarrier</span><br><span class="hljs-comment"> * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</span><br><span class="hljs-comment"> * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</span><br><span class="hljs-comment"> * 直到最后一个线程到达屏障时，屏障才会开门，所有</span><br><span class="hljs-comment"> * 被屏障拦截的线程才会继续干活。</span><br><span class="hljs-comment"> * 线程进入屏障通过CyclicBarrier的await()方法。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 集齐7颗龙珠就可以召唤神龙</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierDemo</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUMBER = <span class="hljs-number">7</span>;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     <span class="hljs-comment">//CyclicBarrier(int parties, Runnable barrierAction) </span><br>     <br>     CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(NUMBER, ()-&gt;&#123;System.out.println(<span class="hljs-string">&quot;*****集齐7颗龙珠就可以召唤神龙&quot;</span>);&#125;) ;<br>     <br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">7</span>; i++) &#123;<br>       <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 星龙珠被收集 &quot;</span>);<br>            cyclicBarrier.await();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>       &#125;, String.valueOf(i)).start();<br>     &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3、Semaphore信号灯"><a href="#3、Semaphore信号灯" class="headerlink" title="3、Semaphore信号灯"></a>3、Semaphore信号灯</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>在信号量上我们定义两种操作：</p>
<p>acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1） 要么一直等下去，直到有线程释放信号量，或超时。</p>
<p>release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: TODO(这里用一句话描述这个类的作用)  </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 在信号量上我们定义两种操作：</span><br><span class="hljs-comment"> * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），</span><br><span class="hljs-comment"> *             要么一直等下去，直到有线程释放信号量，或超时。</span><br><span class="hljs-comment"> * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreDemo</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);<span class="hljs-comment">//模拟3个停车位</span><br>     <span class="hljs-comment">//模拟6部汽车</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">6</span>; i++)&#123;<br>       <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>          <span class="hljs-keyword">try</span>&#123;<br>            semaphore.acquire();<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 抢到了车位&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">5</span>));<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t------- 离开&quot;</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<span class="hljs-keyword">finally</span> &#123;<br>            semaphore.release();<br>          &#125;<br>       &#125;, String.valueOf(i)).start();<br>     &#125;  <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="十一、BlockingQueueDemo阻塞队列"><a href="#十一、BlockingQueueDemo阻塞队列" class="headerlink" title="十一、BlockingQueueDemo阻塞队列"></a>十一、BlockingQueueDemo阻塞队列</h2><h3 id="1、栈与队列"><a href="#1、栈与队列" class="headerlink" title="1、栈与队列"></a>1、栈与队列</h3><p>栈：先进后出，后进先出</p>
<p>队列：先进先出</p>
<h3 id="2、阻塞队列"><a href="#2、阻塞队列" class="headerlink" title="2、阻塞队列"></a>2、阻塞队列</h3><p><img src="/img/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.jpg" srcset="/img/loading.gif" lazyload alt="阻塞队列"></p>
<p>当队列是空的，从队列中获取元素的操作将会被阻塞<br>当队列是满的，从队列中添加元素的操作将会被阻塞</p>
<p>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</p>
<p>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</p>
<h3 id="3、阻塞队列的用处"><a href="#3、阻塞队列的用处" class="headerlink" title="3、阻塞队列的用处"></a>3、阻塞队列的用处</h3><p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</p>
<p>为什么需要BlockingQueue<br>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了</p>
<p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
<h3 id="4、架构梳理、种类分析"><a href="#4、架构梳理、种类分析" class="headerlink" title="4、架构梳理、种类分析"></a>4、架构梳理、种类分析</h3><h4 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h4><p><img src="/img/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9E%B6%E6%9E%84.jpg" srcset="/img/loading.gif" lazyload alt="阻塞队列架构"></p>
<h4 id="种类分析"><a href="#种类分析" class="headerlink" title="种类分析"></a>种类分析</h4><p>1、ArrayBlockingQueue：由数组结构组成的有界阻塞队列。</p>
<p>2、LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</p>
<p>3、PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</p>
<p>4、DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</p>
<p>5、SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。</p>
<p>6、LinkedTransferQueue：由链表组成的无界阻塞队列。</p>
<p>7、LinkedBlockingDeque：由链表组成的双向阻塞队列。</p>
<h3 id="5、BlockingQueue核心方法"><a href="#5、BlockingQueue核心方法" class="headerlink" title="5、BlockingQueue核心方法"></a>5、BlockingQueue核心方法</h3><p><img src="/img/%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95.jpg" srcset="/img/loading.gif" lazyload alt="队列方法"></p>
<p><strong>当阻塞队列满时</strong>，再往队列里add插入元素会抛IllegalStateException:Queuefull，<strong>当阻塞队列空时</strong>，再往队列里remove移除元素会抛NoSuchElementException</p>
<p>特殊值<strong>插入方法</strong>，成功ture失败false，<strong>移除方法</strong>，成功返回出队列的元素，队列里没有就返回null</p>
<p><strong>当阻塞队列满时</strong>，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据or响应中断退出   ，<strong>当阻塞队列空时</strong>，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用</p>
<p>超时退出，当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</p>
<h2 id="十二、ThreadPool线程池"><a href="#十二、ThreadPool线程池" class="headerlink" title="十二、ThreadPool线程池"></a>十二、ThreadPool线程池</h2><h3 id="1、为什么用线程池"><a href="#1、为什么用线程池" class="headerlink" title="1、为什么用线程池"></a>1、为什么用线程池</h3><p>例子：<br>10年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需要来回切换。<br>现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换效率高。</p>
<p>线程池的优势：<br>线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p>它的主要特点为：线程复用;控制最大并发数;管理线程。</p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h3 id="2、线程池如何使用"><a href="#2、线程池如何使用" class="headerlink" title="2、线程池如何使用"></a>2、线程池如何使用</h3><h4 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h4><p><img src="/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%B6%E6%9E%84.jpg" srcset="/img/loading.gif" lazyload alt="线程池架构"></p>
<p>Java中的线程池是通过Executor框架实现的，<br>该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类</p>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*执行长期任务性能好，创建一个线程池，</span><br><span class="hljs-comment">一池有N个固定的线程，有固定线程数的线程*/</span><br>Executors.newFixedThreadPool(<span class="hljs-keyword">int</span>)<br><span class="hljs-comment">//一个任务一个任务的执行，一池一线程</span><br>Executors.newSingleThreadExecutor()	<br><span class="hljs-comment">/*执行很多短期异步任务，线程池根据需要创建新线程，</span><br><span class="hljs-comment">但在先前构建的线程可用时将重用它们。可扩容，遇强则强*/</span><br>Executors.newCachedThreadPool()<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadPoolDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//List list = new ArrayList();</span><br>        <span class="hljs-comment">//List list = Arrays.asList(&quot;a&quot;,&quot;b&quot;);</span><br>        <span class="hljs-comment">//固定数的线程池，一池五线程</span><br><br><span class="hljs-comment">//       ExecutorService threadPool =  Executors.newFixedThreadPool(5); //一个银行网点，5个受理业务的窗口</span><br><span class="hljs-comment">//       ExecutorService threadPool =  Executors.newSingleThreadExecutor(); //一个银行网点，1个受理业务的窗口</span><br>       ExecutorService threadPool =  Executors.newCachedThreadPool(); <span class="hljs-comment">//一个银行网点，可扩展受理业务的窗口</span><br><br>        <span class="hljs-comment">//10个顾客请求</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                threadPool.execute(()-&gt;&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 办理业务&quot;</span>);<br>                &#125;);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            threadPool.shutdown();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="ThreadPoolExecutor底层原理"><a href="#ThreadPoolExecutor底层原理" class="headerlink" title="ThreadPoolExecutor底层原理"></a>ThreadPoolExecutor底层原理</h4><p><img src="/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.jpg" srcset="/img/loading.gif" lazyload alt="线程池原理"></p>
<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h5><p>shutdown 方法调用后，ExecutorService 会有序关闭正在执行的任务，但是不接受新任务。<br>如果任务已经关闭，那么这个方法不会产生任何影响。</p>
<p>它会将线程池的状态设置为 SHUTWDOWN ，正在执行的任务会继续执行下去，线程池会等待任务的执行完毕，而没有执行的线程则会中断。</p>
<h5 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h5><p>shutdownNow 会尝试停止关闭所有正在执行的任务，停止正在等待的任务，并返回正在等待执行的任务列表。</p>
<p>shutdownNow 方法会将线程池的状态设置为 STOP，正在执行和等待的任务则被停止，返回等待执行的任务列表</p>
<h3 id="3、线程池几个重要参数"><a href="#3、线程池几个重要参数" class="headerlink" title="3、线程池几个重要参数"></a>3、线程池几个重要参数</h3><p>1、corePoolSize：线程池中的常驻核心线程数</p>
<p>2、maximumPoolSize：线程池中能够容纳同时执行的最大线程数，此值必须大于等于1</p>
<p>3、keepAliveTime：多余的空闲线程的存活时间当前池中线程数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止</p>
<p>4、unit：keepAliveTime的单位 </p>
<p>5、workQueue：任务队列，被提交但尚未被执行的任务</p>
<p>6、threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可</p>
<p>7、handler：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                          TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-params"><span class="hljs-function">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">                          RejectedExecutionHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-keyword">this</span>.handler = handler;<br>&#125;<br> <br></code></pre></td></tr></table></figure>

<h3 id="4、线程池底层工作原理"><a href="#4、线程池底层工作原理" class="headerlink" title="4、线程池底层工作原理"></a>4、线程池底层工作原理</h3><p><img src="/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" srcset="/img/loading.gif" lazyload alt="线程池工作原理"></p>
<p>1、在创建了线程池后，开始等待请求。<br>2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：<br>  2.1如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；<br>  2.2如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；<br>  2.3如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；<br>  2.4如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。<br>3、当一个线程完成任务时，它会从队列中取下一个任务来执行。<br>4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：<br>    如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。<br>    所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</p>
<h3 id="5、线程池用哪个"><a href="#5、线程池用哪个" class="headerlink" title="5、线程池用哪个"></a>5、线程池用哪个</h3><h4 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h4><h5 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h5><p>等待队列已经排满了，再也塞不下新任务了同时，线程池中的max线程也达到了，无法继续为新任务服务。这个是时候我们就需要拒绝策略机制合理的处理这个问题。</p>
<h5 id="JDK内置的拒绝策略"><a href="#JDK内置的拒绝策略" class="headerlink" title="JDK内置的拒绝策略"></a>JDK内置的拒绝策略</h5><p>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</p>
<p>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</p>
<p>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前任务。</p>
<p>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。<br>如果允许任务丢失，这是最好的一种策略。</p>
<h5 id="以上内置拒绝策略均实现了RejectedExecutionHandle接口"><a href="#以上内置拒绝策略均实现了RejectedExecutionHandle接口" class="headerlink" title="以上内置拒绝策略均实现了RejectedExecutionHandle接口"></a>以上内置拒绝策略均实现了RejectedExecutionHandle接口</h5><h4 id="在工作中单一的-固定数的-可变的三种创建线程池的方法哪个用的多"><a href="#在工作中单一的-固定数的-可变的三种创建线程池的方法哪个用的多" class="headerlink" title="在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多"></a>在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多</h4><p>一个都不用，我们工作中只能使用自定义的</p>
<p>Executors中JDK已经给你提供了，为什么不用？</p>
<p><img src="/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%8B%E5%86%8C.jpg" srcset="/img/loading.gif" lazyload alt="线程池手册"></p>
<h4 id="自定义线程池代码"><a href="#自定义线程池代码" class="headerlink" title="自定义线程池代码"></a>自定义线程池代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadPoolDemo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// List list = new ArrayList();</span><br>        ExecutorService threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<br>                <span class="hljs-number">2</span>,<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">2L</span>,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">3</span>),<br>                Executors.defaultThreadFactory(),<br>                <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());<br><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">8</span>; i++)&#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tmpI = i;<br>                threadPool.submit(() -&gt; &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 处理业务&quot;</span> + <span class="hljs-string">&quot;\t 顾客: &quot;</span> + tmpI);<br>                    <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>                &#125;);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            threadPool.shutdown();<br>        &#125;<br><br>    &#125;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initPool</span><span class="hljs-params">()</span></span>&#123;<br>        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<span class="hljs-comment">//一池5线程</span><br>        ExecutorService threadPool2 = Executors.newSingleThreadExecutor();<span class="hljs-comment">//一池1线程</span><br>        ExecutorService threadPool3 = Executors.newCachedThreadPool();<span class="hljs-comment">//一池N线程</span><br><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">20</span>; i++) &#123;<span class="hljs-comment">//模拟20个请求线程顾客，来办理业务，受理窗口目前有5个</span><br>                threadPool.submit(() -&gt; &#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 处理业务&quot;</span>);<br>                &#125;);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            threadPool.shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6、生产中如设置合理线程池大小的设置"><a href="#6、生产中如设置合理线程池大小的设置" class="headerlink" title="6、生产中如设置合理线程池大小的设置"></a>6、生产中如设置合理线程池大小的设置</h3><h4 id="根据任务类型来配置线程池大小"><a href="#根据任务类型来配置线程池大小" class="headerlink" title="根据任务类型来配置线程池大小"></a>根据任务类型来配置线程池大小</h4><h5 id="如果是-CPU-密集型任务"><a href="#如果是-CPU-密集型任务" class="headerlink" title="如果是 CPU 密集型任务"></a>如果是 CPU 密集型任务</h5><p>如果是 CPU 密集型任务，那么就意味着 CPU 是稀缺资源，这个时候我们通常不能通过增加线程数来提高计算能力，因为线程数量太多，会导致频繁的上下文切换，一般这种情况下，</p>
<p>建议合理的线程数值是 N(CPU)数 + 1。</p>
<h5 id="如果是-I-O-密集型任务"><a href="#如果是-I-O-密集型任务" class="headerlink" title="如果是 I/O 密集型任务"></a>如果是 I/O 密集型任务</h5><p>如果是 I/O 密集型任务，就说明需要较多的等待，这个时候可以参考 Brain Goetz 的推荐方法 </p>
<p>线程数 = CPU核数 × (1 + 平均等待时间/平均工作时间)。</p>
<p>参考值可以是 N(CPU) 核数 * 2。</p>
<h4 id="当然，这只是一个参考值"><a href="#当然，这只是一个参考值" class="headerlink" title="当然，这只是一个参考值"></a>当然，这只是一个参考值</h4><p>具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/07/15/GC/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">GC笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/12/jvm/">
                        <span class="hidden-mobile">JVM 体系结构</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
